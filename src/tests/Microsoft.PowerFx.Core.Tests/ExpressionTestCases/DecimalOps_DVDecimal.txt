#SETUP: disable:NumberIsFloat

// DV Decimal: These tests are compabtible with the SQL compiler used by Dataverse, with a max/min of +/-100,000,000,000 and ten decimal places.  
// Variants of 10000000000.0000000001 are used which is not representable in floating point (rounds to 10000000000).  
// These tests are also runnable with the C# semantics for decimal which is why they are included in the Power-Fx repo, ensuring consistency between DV and C#.
// Where possible, unless specifically testing the C# range, should be written in the DV rnage.

// decimal op decimal -> decimal

>> 10000000000.0000000002 * 2
20000000000.0000000004

>> 20000000000.0000000004 / 2
10000000000.0000000002

>> 10000000000.0000000002 - 2
9999999998.0000000002

>> 10000000000.0000000002 + 2
10000000002.0000000002

>> 10000000000.0000000001 = 10000000000
false

>> 10000000000.0000000001 <> 10000000000
true

>> 10000000000.0000000001 > 10000000000
true

>> 10000000000.0000000001 < 10000000000
false

>> 10000000000.0000000001 >= 10000000000
true

>> 10000000000.0000000001 <= 10000000000
false

>> 10000000000.00000001%
100000000.0000000001

>> -10000000000.0000000001
-10000000000.0000000001

>> 2 * 10000000000.0000000001
20000000000.0000000002

>> 2 / 10000000000.0000000001
0.0000000002

>> 20000000000 - 10000000000.0000000001
9999999999.9999999999

>> 20000000000 + 10000000000.0000000001
30000000000.0000000001

>> 10000000000 = 10000000000.0000000001
false

>> 10000000000 <> 10000000000.0000000001
true

>> 10000000000 > 10000000000.0000000001 
false

>> 10000000000 < 10000000000.0000000001
true

>> 10000000000 >= 10000000000.0000000001
false

>> 10000000000 <= 10000000000.0000000001
true

>> 20000000000 = 10000000000.0000000001
false

>> 20000000000 <> 10000000000.0000000001
true

>> 20000000000 > 10000000000.0000000001 
true

>> 20000000000 < 10000000000.0000000001
false

>> 20000000000 >= 10000000000.0000000001
true

>> 20000000000 <= 10000000000.0000000001
false

// test with float (Sqrt always returns float)

>> Sqrt(9)%
0.03

>> 3*(10000000000.00000001%)
300000000.0000000003

>> Sqrt(9)*(10000000000.00000001%)
300000000

>> 10000000000.0000000001 * Sqrt(4)
20000000000

>> 10000000000.0000000001 / Sqrt(4)
5000000000

>> 10000000000.0000000001 - Sqrt(4)
9999999998

>> 10000000000.0000000001 + Sqrt(4)
10000000002

>> 10000000000.0000000001 = Sqrt(4)
false

// rounds decimal to 10000000000 as Sqrt returns float
// Float("1e20") is exact and Sqrt(Float("1e20")) is exact.  Float is required here because DV Decimal doesn't support this range.

>> 10000000000.0000000001 = Sqrt(Float("1e20"))
true

>> 10000000000.0000000001 <> Sqrt(Float("1e20"))
false

>> 10000000000.0000000001 > Sqrt(Float("1e20"))
false

>> 10000000000.0000000001 < Sqrt(Float("1e20"))
false

>> 10000000000.0000000001 >= Sqrt(Float("1e20"))
true

>> 10000000000.0000000001 <= Sqrt(Float("1e20"))
true

>> Sqrt(4) * 10000000000.0000000001
20000000000

>> Decimal(Sqrt(4)) * 10000000000.0000000001
20000000000.0000000002

>> Sqrt(4) / 10000000000.0000000001
2E-10

>> Sqrt(4) - 10000000000.0000000001
-9999999998

>> Sqrt(4) + 10000000000.0000000001
10000000002

>> Sqrt(Float("1e20")) = 10000000000.0000000001
true

>> Sqrt(Float("1e20")) <> 10000000000.0000000001
false

>> Sqrt(Float("1e20")) > 10000000000.0000000001 
false

>> Sqrt(Float("1e20")) < 10000000000.0000000001
false

>> Sqrt(Float("1e20")) >= 10000000000.0000000001
true

>> Sqrt(Float("1e20")) <= 10000000000.0000000001
true

// decimal op string -> decimal

>> 10000000000.0000000001 * "2"
20000000000.0000000002

>> 10000000000.000000001 / "2"
5000000000.0000000005

>> 10000000000.0000000001 - "2"
9999999998.0000000001

>> 10000000000.0000000001 + "2"
10000000002.0000000001

>> "10000000000.0000000001"%
100000000.000000000001

>> -"10000000000.0000000001"
-10000000000.0000000001

>> "2" * 10000000000.0000000001
20000000000.0000000002

>> "2" / 10000000000.0000000001
0.0000000002

>> "2" - 10000000000.0000000001
-9999999998.0000000001

>> "2" + 10000000000.0000000001
10000000002.0000000001

// decimal op boolean -> decimal

>> 10000000000.0000000001 * true
10000000000.0000000001

>> 10000000000.0000000001 / true
10000000000.0000000001

>> 10000000000.0000000001 - true
9999999999.0000000001

>> 10000000000.0000000001 + true
10000000001.0000000001

>> true%
0.01

>> true% * 10000000000.00000001
100000000.0000000001

>> -true
-1

>> (-true) * 10000000000.0000000001
-10000000000.0000000001

>> true * 10000000000.0000000001
10000000000.0000000001

>> true / 10000000000.0000000001
0.0000000001

>> true - 10000000000.0000000001
-9999999999.0000000001

>> true + 10000000000.0000000001
10000000001.0000000001

// decimal op untyped -> decimal

>> 10000000000.0000000001 * ParseJSON("2")
20000000000.0000000002

>> ParseJSON("10000000000.0000000001") * 2
20000000000.0000000002

>> ParseJSON("10000000000.0000000001") * ParseJSON("2")
20000000000.0000000002

>> 10000000000.000000001 / ParseJSON("2")
5000000000.0000000005

>> ParseJSON("10000000000.000000001") / 2
5000000000.0000000005

>> Round( ParseJSON("10000000000.000000001") / ParseJSON("20000000000.0000000002"), 5 )
0.5

>> 10000000000.0000000001 - ParseJSON("2")
9999999998.0000000001

>> ParseJSON("10000000000.0000000001") - 2
9999999998.0000000001

>> ParseJSON("10000000000.0000000001") - ParseJSON("20000000000.0000000002")
-10000000000.0000000001

>> 10000000000.0000000001 + ParseJSON("2")
10000000002.0000000001

>> ParseJSON("10000000000.0000000001") + 2
10000000002.0000000001

>> ParseJSON("10000000000.0000000001") + ParseJSON("20000000000.0000000002")
30000000000.0000000003

>> 10000000000.0000000001 = ParseJSON("1")
false

>> 10000000000.0000000001 = ParseJSON("10000000000.0000000001")
true

>> 10000000000.0000000001 = ParseJSON("10000000000")
false

>> ParseJSON("10000000000.0000000001") = 1
false

>> ParseJSON("10000000000.0000000001") = 10000000000.0000000001
true

>> ParseJSON("10000000000.0000000001") = 10000000000
false

>> ParseJSON("10000000000.0000000001") = ParseJSON("10000000000.0000000001")
Errors: Error 36-37: Incompatible types for comparison. These types can't be compared: UntypedObject, UntypedObject.

>> 10000000000.0000000001 <> ParseJSON("1")
true

>> ParseJSON("10000000000.0000000001") <> 1
true

>> ParseJSON("10000000000.0000000001") <> 10000000000.0000000001
false

>> ParseJSON("10000000000.0000000001") <> ParseJSON("10000000000.0000000001")
Errors: Error 36-38: Incompatible types for comparison. These types can't be compared: UntypedObject, UntypedObject.

>> 10000000000.0000000001 > ParseJSON("1")
true

>> ParseJSON("10000000000.0000000001") > 1
true

>> ParseJSON("10000000000.0000000001") > 10000000000.0000000001
false

>> ParseJSON("10000000000.0000000001") > ParseJSON("10000000000.0000000001")
Errors: Error 36-37: This operation isn't valid on these types: UntypedObject, UntypedObject.

>> 10000000000.0000000001 < ParseJSON("1")
false

>> ParseJSON("10000000000.0000000001") < 1
false

>> ParseJSON("10000000000.0000000001") < 10000000000.0000000001
false

>> ParseJSON("10000000000.0000000001") < ParseJSON("10000000000.0000000001")
Errors: Error 36-37: This operation isn't valid on these types: UntypedObject, UntypedObject.

>> 10000000000.0000000001 >= ParseJSON("1")
true

>> ParseJSON("10000000000.0000000001") >= 1
true

>> ParseJSON("10000000000.0000000001") >= 10000000000.0000000001
true

>> ParseJSON("10000000000.0000000001") >= ParseJSON("10000000000.0000000001")
Errors: Error 36-38: This operation isn't valid on these types: UntypedObject, UntypedObject.

>> 10000000000.0000000001 <= ParseJSON("1")
false

>> ParseJSON("10000000000.0000000001") <= 1
false

>> ParseJSON("10000000000.0000000001") <= 10000000000.0000000001
true

>> ParseJSON("10000000000.0000000001") <= ParseJSON("10000000000.0000000001")
Errors: Error 36-38: This operation isn't valid on these types: UntypedObject, UntypedObject.

>> ParseJSON("2")%
0.02

>> ParseJSON("10000000000.00000001")%
100000000.0000000001

>> ParseJSON("2")% * 10000000000.00000001
200000000.0000000002

>> -ParseJSON("2")
-2

>> -ParseJSON("10000000000.0000000001")
-10000000000.0000000001

>> (-ParseJSON("2")) * 10000000000.0000000001
-20000000000.0000000002

>> ParseJSON("2") * 10000000000.0000000001
20000000000.0000000002

>> ParseJSON("2") / 10000000000.0000000001
0.0000000002

>> ParseJSON("2") - 10000000000.0000000001
-9999999998.0000000001

>> ParseJSON("2") + 10000000000.0000000001
10000000002.0000000001

>> ParseJSON("10000000000") = 10000000000.0000000001
false

>> ParseJSON("10000000000") <> 10000000000.0000000001
true

>> ParseJSON("10000000000") > 10000000000.0000000001
false

>> ParseJSON("10000000000") < 10000000000.0000000001
true

>> ParseJSON("10000000000") >= 10000000000.0000000001
false

>> ParseJSON("10000000000") <= 10000000000.0000000001
true

>> ParseJSON("20000000000") = 10000000000.0000000001
false

>> ParseJSON("20000000000") <> 10000000000.0000000001
true

>> ParseJSON("20000000000") > 10000000000.0000000001
true

>> ParseJSON("20000000000") < 10000000000.0000000001
false

>> ParseJSON("20000000000") >= 10000000000.0000000001
true

>> ParseJSON("20000000000") <= 10000000000.0000000001
false

// decimal op datetime -> number

// 2958465.0000000001 cannot be represented in floating point and is a good test for decimal

>> 10000000000.0000000001 * Date(1900,1,1)
20000000000.0000000002

>> 10000000000.000000001 / Date(1900,1,1)
5000000000.0000000005

// 10000000000.0000000001 - Date(1900,1,1)   // Decimal TODO: SubtractNumberAndDate in LibraryOperators.cs is unimplemented?  Works in Canvas?

>> 2958463.0000000001 + Date(1900,1,1)
Date(9999,12,31)

>> 2958465 = Date(9999,12,31)
true

>> 2958465.0000000001 = Date(9999,12,31)
false

>> 2958465.0000000001 <> Date(9999,12,31)
true

>> 2958465.0000000001 > Date(9999,12,31)
true

>> 2958465.0000000001 < Date(9999,12,31)
false

>> 2958465.0000000001 >= Date(9999,12,31)
true

>> 2958465.0000000001 <= Date(9999,12,31)
false

>> Date(9999,12,31)%
29584.65

>> Date(1900,1,1)% * 10000000000.0000001
200000000.000000002

>> -Date(1900,1,1) 
Date(1899,12,28)

>> (-Date(1900,1,1)) * 10000000000.0000001
-20000000000.0000002

>> Date(1900,1,1) * 10000000000.0000001
20000000000.0000002

>> Date(9999,1,1) - 1000000.0000001
Date(7261,2,2)

>> Date(1900,1,1) + 1000000.0000001
Date(4637,11,28)

>> Date(9999,12,31) = 2958463.0000000001
false

>> Date(9999,12,31) <> 2958463.0000000001
true

>> Date(9999,12,31) > 2958463.0000000001
true

>> Date(9999,12,31) < 2958463.0000000001
false

>> Date(9999,12,31) >= 2958463.0000000001
true

>> Date(9999,12,31) <= 2958463.0000000001
false

// decimal op datetime -> number

>> 10000000000.0000001 * DateTime(1900,1,1,12,0,0)
25000000000.00000025

>> 10000000000.0000001 / DateTime(1900,1,1,12,0,0)
4000000000.00000004

//10000000000.0000001 - DateTime(1900,1,1,12,0,0)   // Decimal TODO: SubtractNumberAndDate in LibraryOperators.cs is unimplemented?  Works in Canvas?

>> 1000000.0000001 + DateTime(1900,1,1,12,0,0)
DateTime(4637,11,28,12,0,0,9)

>> DateTime(1900,1,1,12,0,0)%
0.025

>> DateTime(1900,1,1,12,0,0)% * 10000000000.0000001
250000000.0000000025

//-DateTime(1900,1,1,12,0,0) -- issue https://github.com/microsoft/Power-Fx/issues/1176

// (-DateTime(1900,1,1,12,0,0)) * 10000000000.0000001 -- issue https://github.com/microsoft/Power-Fx/issues/1176

>> DateTime(1900,1,1,12,0,0) * 10000000000.0000001
25000000000.00000025

>> Round( DateTime(1900,1,1,12,0,0) / 1000000000.00001, 10 )
0.0000000025

>> DateTime(9999,1,1,12,0,0) - 1000000.00000000001
DateTime(7261,2,3,12,0,0,0)

>> DateTime(1900,1,1,12,0,0) + 2000000.00000001
DateTime(7375,10,25,12,0,0,1)

>> DateTime(1900,1,1,0,0,0) = 10000000000.0000001
false


>> DateTime(1900,1,1,0,0,0) <> 10000000000.0000001
true

>> DateTime(1900,1,1,0,0,0) > 10000000000.0000001
false

>> DateTime(1900,1,1,0,0,0) < 10000000000.0000001
true

>> DateTime(1900,1,1,0,0,0) >= 10000000000.0000001
false

>> DateTime(1900,1,1,0,0,0) <= 10000000000.0000001
true

>> DateTime(1900,1,0,0,0,0) = 10000000000.0000001
false

>> DateTime(1900,1,0,0,0,0) <> 10000000000.0000001
true

>> DateTime(1900,1,0,0,0,0) > 10000000000.0000001
false

>> DateTime(1900,1,0,0,0,0) < 10000000000.0000001
true

>> DateTime(1900,1,0,0,0,0) >= 10000000000.0000001
false

>> DateTime(1900,1,0,0,0,0) <= 10000000000.0000001
true

>> DateTime(9999,12,31,0,0,0) = 2958465.0000000001
false

>> DateTime(9999,12,31,0,0,0) = 2958465
true

>> DateTime(9999,12,31,0,0,0) <> 2958465.0000000001
true

>> DateTime(9999,12,31,0,0,0) > 2958465.0000000001
false

>> DateTime(9999,12,31,0,0,0) < 2958465.0000000001
true

>> DateTime(9999,12,31,0,0,0) >= 2958465.0000000001
false

>> DateTime(9999,12,31,0,0,0) <= 2958465.0000000001
true

// decimal op blank -> decimal

>> 10000000000.0000001 * Blank()
0

>> 10000000000.0000001 / Blank()
Error({Kind:ErrorKind.Div0})

>> 10000000000.0000001 - Blank()
10000000000.0000001

>> 10000000000.0000001 + Blank()
10000000000.0000001

>> Blank()%
0

>> Blank()% + 10000000000.0000001
10000000000.0000001

>> -Blank()
0

>> (-Blank()) + 10000000000.0000001
10000000000.0000001

>> Blank() * 10000000000.0000001
0

>> Blank() / 10000000000.0000001
0

>> Blank() - 10000000000.0000001
-10000000000.0000001

>> Blank() + 10000000000.0000001
10000000000.0000001

>> Blank() = 10000000000.0000001
false

>> Blank() <> 10000000000.0000001
true

>> Blank() > 10000000000.0000001
false

>> Blank() < 10000000000.0000001
true

>> Blank() >= 10000000000.0000001
false

>> Blank() <= 10000000000.0000001
true

>> Blank() = 0.000000001
false

>> Blank() <> 0.000000001
true

>> Blank() > 0.000000001
false

>> Blank() < 0.000000001
true

>> Blank() >= 0.000000001
false

>> Blank() <= 0.000000001
true

>> Blank() = 0
false

>> Blank() <> 0
true

>> Blank() > 0
false

>> Blank() < 0
false

>> Blank() >= 0
true

>> Blank() <= 0
true

// scientific notation works with decimal, does not imply floating point

>> 100000000000000000001e-10 + 1
10000000001.0000000001

>> 1 + 100000000000000000001e-10
10000000001.0000000001

