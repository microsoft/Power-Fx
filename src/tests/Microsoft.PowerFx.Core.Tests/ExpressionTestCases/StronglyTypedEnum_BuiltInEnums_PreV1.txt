#SETUP: disable:StronglyTypedBuiltinEnums,disable:PowerFxV1CompatibilityRules,AllEnumsSetup,RegEx,EnableJsonFunctions

// **** Using built in enums only, Pre V1. ****
// Some enum varients are not represented in the Builtin set, including, for example, any Boolean enums.
// For tihs reason, the companion _TestEnums version of this file uses built in and additional test enums.
// While this version remains compatible with Canvas.
//
// Expected resutls in this file were captured before the April 2024 changes for testing compatibilty with the old settings.

// Strongly typed enums were strengthened to:
//    0. Strongly typed enum usage is the most common scenario and what Intellisense will suggest.
//    1. Avoid passing the wrong kind of enum to a function. For example JSON( [1,2,3], Match.IgnoreCase )
//    2. Avoid passing an enum where a scalar was expected, except for text backed enums. For example Mid( "foo", StartOfWeek.Tuesday )
//    3. Avoid passing a scalar where an enum was expected, excepf for text backed enums. For example Weekday( Now(), 12 )
//
// Default operations with backing type
//    4. Equals/not equals between enum values of the same enum is always supported.  For example, StartOfWeek.Tuesday = StartOfWeek.Monday
//    5. By default, Equals/not equals with the backing kind is not supported.  For example, StartOfWeek.Tuesday = 12
//    6. By default, Order comparisons between number based enums are not supported, by default. For example StartOfWeek.Tuesday < StartOfWeek.Monday
//    7. By default, math operations between number based enums are never supported. For example, StartOfWeek.Tuesday + StartOfWeek.Monday 
//    8. By default, Boolean operations between Boolean based enums is not supported, but can be overriden with CanCoerceToBackingKind
//    9. If the underlying value is desired, the Text, Value, Decimal, Float, and Boolean functions can be called to get the backing value.
//
// In addition, there are flags for each option set that govern how it can be used.  Default is no flags, used by Dataverse option sets.
//   10. CanCoerceFromBackingKind - For example, Match which allows a string in place of the enum
//   11. CanCoerceToBackingKind - For example, ErrorKind that can be used as a number
//   12. CanConcatenateStronglyTyped (text only) - For example, JSONFormat which can concatenate different members together to create a new member
//   13. CanCompareNumeric (numbers only) - For example, ErrorKind can compare values
//   14. CanConcatenateStronglyTyped & CanCoerceFromBackingKind - An important combination, used by Match, allows strings and enums to be mixed
//
// Misc
//   15. Since there is no longer an Accepts relationship between enums and their backing kinds, more likely to get Void results
//   16. Everything coerces to string

//============================================================================================================
//
// 0. Strongly typed enum usage is the most common scenario and what Intellisense will suggest.
//

>> Sort( [1,2,3], SortOrder.Descending )
Table({Value:1},{Value:2},{Value:3})

>> Match( "info@contoso.com", Match.Email )
{FullMatch:"info@contoso.com",StartMatch:1,SubMatches:Table()}

>> JSON( [1,2,3], JSONFormat.FlattenValueTables )
"[1,2,3]"

>> Weekday( Date(1990,1,1), StartOfWeek.Tuesday )
7

>> ColorFade( Color.Red, 10% )
RGBA(255,25,25,1)

//============================================================================================================
//
// 1. Avoid passing the wrong kind of enum to a function. For example JSON( [1,2,3], Match.IgnoreCase )
//

>> Sort( [1,2,3], Value, JSONFormat.IndentFour )
Table({Value:1},{Value:2},{Value:3})

>> Match( "info@contoso.com", JSONFormat.IndentFour )
Blank()

>> Match( "asdf", SortOrder.Ascending )
Blank()

>> JSON( [1,2,3], MatchOptions.IgnoreCase )
"[{""Value"":1},{""Value"":2},{""Value"":3}]"

>> JSON( [1,2,3], Match.Email )
"[{""Value"":1},{""Value"":2},{""Value"":3}]"

>> JSON( [1,2,3], StartOfWeek.Tuesday )
"[{""Value"":1},{""Value"":2},{""Value"":3}]"

>> Match( "hi", JSONFormat.IndentFour )
Blank()

>> Match( "hi", "h.*", JSONFormat.IndentFour )
{FullMatch:"hi",StartMatch:1,SubMatches:Table()}

>> Match( "hi", Match.Email, JSONFormat.IndentFour )
Blank()

>> IsMatch( "hi", JSONFormat.IndentFour )
false

>> IsMatch( "hi", "h.*", JSONFormat.IndentFour )
true

>> IsMatch( "hi", Match.Email, JSONFormat.IndentFour )
false

>> MatchAll( "hi", JSONFormat.IndentFour )
Table()

>> MatchAll( "hi", "h.*", JSONFormat.IndentFour )
Table({FullMatch:"hi",StartMatch:1,SubMatches:Table()})

>> MatchAll( "hi", Match.Email, JSONFormat.IndentFour )
Table()

>> Text( 12, JSONFormat.IndentFour )
"4"

>> Text( 12, MatchOptions.IgnoreCase )
Error({Kind:ErrorKind.InvalidArgument})

>> Weekday( Date(1980,1,1), ErrorKind.Div0 )
7

>> Weekday( Date(1980,1,1), JSONFormat.IndentFour )
Error({Kind:ErrorKind.InvalidArgument})

//===========================================================================================================
//
// 2. Avoid passing an enum where a scalar was expected, except for text.  For example Mid( "foo", StartOfWeek.Tuesday ). 
//

>> Mid( "foo", StartOfWeek.Tuesday )
""

>> Mid( "foo", 1, StartOfWeek.Monday )
"fo"

>> Left( "foo", StartOfWeek.Sunday )
"f"

>> Int( StartOfWeek.Tuesday )
12

>> Power( StartOfWeek.Saturday, StartOfWeek.MondayZero )
4096

>> Mod( StartOfWeek.Tuesday, StartOfWeek.Tuesday )
0

>> Left( "hi", StartOfWeek.Sunday )
"h"

// Text backed enums can always we passed as text, as all enums coerce to text

>> Mid( Match.Letter, 1, 1 )
"\"

//===========================================================================================================
//
// 3. Avoid passing a scalar where an enum was expected, excepf for text backed enums. For example Weekday( Now(), 12 )
//

>> Weekday( Date(1990,1,1), 12 )
7

>> Sort( [1,2,3], Value, "descending" )
Table({Value:3},{Value:2},{Value:1})

>> JSON( [1,2,3], "_" )
"[1,2,3]"

>> Match( "howdy", "h", "c" )
{FullMatch:"h",StartMatch:1,SubMatches:Table()}

>> IsMatch("Foo", 17)
Errors: Error 15-17: Regular expressions must be constant values.

>> IsMatch("Foo", 1/0)
Errors: Error 16-17: Regular expressions must be constant values.

//===========================================================================================================
//
// 4. Equals/not equals between enum values of the same enum is always supported.  For example, StartOfWeek.Tuesday = StartOfWeek.Monday
//

>> StartOfWeek.Tuesday = StartOfWeek.Wednesday
false

>> StartOfWeek.Tuesday <> StartOfWeek.Wednesday
true

>> JSONFormat.IndentFour = JSONFormat.Compact
false

>> JSONFormat.IndentFour <> JSONFormat.Compact
true

>> SortOrder.Ascending = SortOrder.Descending
false

>> SortOrder.Ascending <> SortOrder.Descending
true

>> ErrorKind.Div0 = ErrorKind.Custom
false

>> ErrorKind.Div0 <> ErrorKind.Unknown
true

>> Color.Red = Color.Pink
false

>> Color.Red <> Color.Pink
true

>> ErrorKind.Custom <> ErrorKind.Custom
false

>> ErrorKind.Div0 <> ErrorKind.Custom
true

// Not supported between different enums, even if the same backing kind or if CanCoerceToBackindKind is true

>> StartOfWeek.Tuesday = ErrorKind.Div0
false

>> StartOfWeek.Tuesday <> ErrorKind.Unknown
false

>> JSONFormat.IndentFour = SortOrder.Descending
false

>> JSONFormat.IndentFour <> Match.Email
true

//===========================================================================================================
//
//  5. By default, Equals/not equals with the backing kind is not supported.  For example, StartOfWeek.Tuesday = 12
//

>> StartOfWeek.Tuesday = 12
true

>> StartOfWeek.Tuesday <> 14
true

>> JSONFormat.IndentFour = "4"
true

>> JSONFormat.IndentFour <> "_"
true

//===========================================================================================================
//
// 6. By default, Order comparisons between number based enums are not supported by default, for example StartOfWeek.Tuesday < StartOfWeek.Monday
//

>> StartOfWeek.Tuesday > 3
true

>> StartOfWeek.Tuesday > StartOfWeek.Wednesday
false

>> StartOfWeek.Friday < 5
false

>> StartOfWeek.Friday < StartOfWeek.Sunday
false

>> StartOfWeek.Friday <= 5
false

>> StartOfWeek.Friday <= StartOfWeek.Sunday
false

>> StartOfWeek.Friday >= 5
true

>> StartOfWeek.Friday >= StartOfWeek.Sunday
true

//===========================================================================================================
//
// 7. By default, math operations between number based enums are never supported. For example, StartOfWeek.Tuesday + StartOfWeek.Monday 
//

>> StartOfWeek.Tuesday + 3
15

>> StartOfWeek.Tuesday + StartOfWeek.Thursday
26

>> StartOfWeek.Tuesday * 2
24

//===========================================================================================================
//
// 8. By default, Boolean operations between Boolean based enums is not supported, but can be overriden with CanCoerceToBackingKind
//

//===========================================================================================================
//
// 9. If the underlying value is desired, the Text, Value, Decimal, Float, and Boolean functions can be called to get the backing value.
//

// Text can be called on all option set values

>> Text( Match.Digit )
"\d"

>> Text( StartOfWeek.Tuesday )
"12"

>> Text( ErrorKind.Div0 )
"13"

>> Text( JSONFormat.IndentFour )
"4"

>> Value( StartOfWeek.Friday )
15

>> Value( ErrorKind.Unknown )
12

>> Value( Match.Digit )
Error({Kind:ErrorKind.InvalidArgument})

>> Value( JSONFormat.IndentFour )
4

>> Float( StartOfWeek.Friday )
15

>> Float( ErrorKind.Unknown )
12

>> Float( Match.Digit )
Error({Kind:ErrorKind.InvalidArgument})

>> Float( JSONFormat.IndentFour )
4

>> Decimal( StartOfWeek.Friday )
15

>> Decimal( ErrorKind.Unknown )
12

>> Decimal( Match.Digit )
Error({Kind:ErrorKind.InvalidArgument})

>> Decimal( JSONFormat.IndentFour )
4

>> Boolean( StartOfWeek.Friday )
true

>> Boolean( ErrorKind.Unknown )
true

>> Boolean( Match.Digit )
Error({Kind:ErrorKind.InvalidArgument})

>> Boolean( JSONFormat.IndentFour )
Error({Kind:ErrorKind.InvalidArgument})

// no constructor for Color values

//===========================================================================================================
//
// 10. CanCoerceFromBackingKind - For example, Match which allows a string in place of the enum
//

// Match (and friends) allows coercion from the backing kind for the regular expression

>> Match( "a3d4", Match.Digit )
{FullMatch:"3",StartMatch:2,SubMatches:Table()}

>> Match( "a3d4", "\d")
{FullMatch:"3",StartMatch:2,SubMatches:Table()}

>> IsMatch( "a3d4", Match.Digit )
false

>> IsMatch( "a3d4", "\d")
false

>> MatchAll( "a3d4", Match.Digit )
Table({FullMatch:"3",StartMatch:2,SubMatches:Table()},{FullMatch:"4",StartMatch:4,SubMatches:Table()})

>> MatchAll( "a3d4", "\d")
Table({FullMatch:"3",StartMatch:2,SubMatches:Table()},{FullMatch:"4",StartMatch:4,SubMatches:Table()})

// Most other enums do not, see section 1 above

//===========================================================================================================
//
// 11. CanCoerceToBackingKind - For example, ErrorKind that can be used as a number
//

// ErrorKind allows coerction to the backing kind

>> Error( {Kind: ErrorKind.Div0} )
Error({Kind:ErrorKind.Div0})

>> Error( {Kind: 13} )
Error({Kind:ErrorKind.Div0})

>> ColorFade( Color.Pink, 10% )
RGBA(255,198,208,1)

>> ColorFade( RGBA(1,4,9,100%), 10% )
RGBA(26,29,33,1)

// ErrorKind has CoerceTo set

>> ErrorKind.Unknown + 2
14

>> ErrorKind.Unknown * 2
24

>> ErrorKind.Unknown / 2
6

>> ErrorKind.Unknown ^ 2
144

// Equals/not equals comparisons

>> Color.Red = RGBA(1,1,1,1)
false

>> Color.Red <> RGBA(1,1,1,1)
true

>> Color.Red = RGBA(255,0,0,1)
true

>> Color.Red <> RGBA(255,0,0,1)
false

>> ErrorKind.Div0 = 13
true

>> ErrorKind.Div0 <> 13
false

// Most other enums do not, see section 2 above

//===========================================================================================================
//
// 12. CanConcatenateStronglyTyped (text only) - For example, JSONFormat which can concatenate different members together to create a new member
//

// By default, concatenation results in a text string that won't match strongly typed arguments

>> Sort( [1,2,3], Value, SortOrder.Descending & SortOrder.Ascending )
Table({Value:1},{Value:2},{Value:3})

>> JSON( [1,2,3], JSONFormat.Compact & Match.Letter )
"[{""Value"":1},{""Value"":2},{""Value"":3}]"

// Since the Match supports CanCoerceBackingKind, any concatenation combination is supported
>> Match( "334", Match.Digit & Match.Digit & JSONFormat.IndentFour )
{FullMatch:"334",StartMatch:1,SubMatches:Table()}

// Concatenation can be allowed between members of hte option set and still retain strong typing with IExternalOptionSet.CanConcatenateStronglyTyped

>> JSON( [1,2,3], JSONFormat.IgnoreBinaryData & JSONFormat.FlattenValueTables )
"[1,2,3]"

>> JSON( [1,2,3], JSONFormat.IgnoreBinaryData & "_" )
"[1,2,3]"

>> JSON( [4,5,6], "_" )
"[4,5,6]"

// Concatenation can be allowed with text strings and still retain strong typing with IExternalOptionSet.CanCoerceBackingKind

>> Match( "33this is ok", Concatenate( Match.Digit, Match.Digit, "this is ok" ) )
{FullMatch:"33this is ok",StartMatch:1,SubMatches:Table()}

>> Match( "33this is ok", Match.Digit & Match.Digit & "this is ok" )
{FullMatch:"33this is ok",StartMatch:1,SubMatches:Table()}

>> Match( "33this is ok", "\d\dthis is ok" )
{FullMatch:"33this is ok",StartMatch:1,SubMatches:Table()}

>> Match( "33this is ok", "\d" & "\d" & "this is ok" )
{FullMatch:"33this is ok",StartMatch:1,SubMatches:Table()}

// Otherwise concatenate results in a text string, but that won't match strongly typed arguments

>> JSON( "foo", Concatenate( Match.Digit, JSONFormat.IndentFour ) )
"""foo"""

>> JSON( "foo", Match.Digit & JSONFormat.IndentFour )
"""foo"""

//===========================================================================================================
//
// 13. CanCompareNumeric (numbers only) - For example, ErrorKind can compare values
//

// Long term, ErrorKind should be a strongly typed value and no longer use CoerceTo and depend on CompareNumeric/CoerceFrom instead

>> ErrorKind.Unknown < ErrorKind.Custom
true

>> ErrorKind.Unknown < 1000
true

>> ErrorKind.Unknown > 1000
false

>> ErrorKind.Unknown <= 1000
true

>> ErrorKind.Unknown >= 1000
false

>> ErrorKind.Custom = 1000
true

// Most other number backeded enums can not, see section 5 above

//===========================================================================================================
//
// 14. CanConcatenateStronglyTyped & CanCoerceFromBackingKind - An important combination, used by Match, allows strings and enums to be mixed
//

>> Match( "a34d", Match.Digit & "\d" )
{FullMatch:"34",StartMatch:2,SubMatches:Table()}

>> Match( "a34d", "\d" & Match.Digit )
{FullMatch:"34",StartMatch:2,SubMatches:Table()}

>> Match( "a34d", Concatenate( Match.Digit, "\d" ) )
{FullMatch:"34",StartMatch:2,SubMatches:Table()}

>> Match( "a34d", Concatenate( "\d", Match.Digit ) )
{FullMatch:"34",StartMatch:2,SubMatches:Table()}

>> Text(Match.Digit) & Text(SortOrder.Ascending)
"\dascending"

>> SortOrder.Ascending & Match.Digit
"ascending\d"

>> Text(SortOrder.Ascending) & Text(Match.Digit)
"ascending\d"

// Concatenate results in at least a text string for all situations, some will result in a strongly typed enum (see below)

>> Concatenate( Match.Digit, Match.Digit, JSONFormat.IndentFour )
"\d\d4"

>> Match.Digit & Match.Digit & JSONFormat.IndentFour
"\d\d4"

>> Concatenate( Match.Digit, Match.Digit, "this is ok" )
"\d\dthis is ok"

>> Text( Concatenate( Match.Digit, Match.Digit, "this is ok" ) )
"\d\dthis is ok"

>> Match.Digit & Match.Digit & "this is ok" 
"\d\dthis is ok"

>> Text( Match.Digit & Match.Digit & "this is ok" )
"\d\dthis is ok"

>> Match.Digit & "this is ok" & Match.Digit
"\dthis is ok\d"

>> Text( Match.Digit & "this is ok" & Match.Digit )
"\dthis is ok\d"

>> Match.Digit & SortOrder.Ascending
"\dascending"

//===========================================================================================================
//
// 15. Since there is no longer an Accepts relationship between enums and their backing kinds, more likely to get Void results
//

>> If(true, TimeUnit.Seconds, "A")
"seconds"

>> If(true, TimeUnit.Minutes, TimeUnit.Seconds)
"minutes"

>> If(true, 1, StartOfWeek.Tuesday)
1

>> If(true, StartOfWeek.Tuesday, 1)
12

//===========================================================================================================
//
// 16. Everything coerces to string
//

>> Text( StartOfWeek.Sunday )
"1"

>> "Label:" & StartOfWeek.Sunday
"Label:1"

>> Mid( StartOfWeek.Sunday, 2 )
""

>> Len( StartOfWeek.Sunday )
1

>> Text( Match.MultipleDigits )
"\d+"

>> "Label:" & Match.MultipleDigits
"Label:\d+"

>> Text( "Label:" & Match.MultipleDigits )
"Label:\d+"

>> Mid( Match.MultipleDigits, 2 )
"d+"

>> Len( Match.MultipleDigits )
3

>> Text( MatchOptions.IgnoreCase )
"i"

>> "Label:" & MatchOptions.IgnoreCase
"Label:i"

>> Text( ErrorKind.FileNotFound )
"17"

>> "Label:" & ErrorKind.FileNotFound
"Label:17"
