#SETUP:!NumberIsFloat
// decimal aware aggregate functions

>> Sum( 1.0000000000000000000000001, 2.0000000000000000000000002)
3.0000000000000000000000003

>> Sum( [1.0000000000000000000000001, 2.0000000000000000000000002], Value )
3.0000000000000000000000003

>> Average( 1.0000000000000000000000001, 2.0000000000000000000000002 )
1.50000000000000000000000015

>> Average( [1.0000000000000000000000001, 2.0000000000000000000000002], Value )
1.50000000000000000000000015

>> Min( 1.0000000000000000000000001, 2.0000000000000000000000002 )
1.0000000000000000000000001

>> Min( [1.0000000000000000000000001, 2.0000000000000000000000002], Value )
1.0000000000000000000000001

>> Max( 1.0000000000000000000000001, 2.0000000000000000000000002 )
2.0000000000000000000000002

>> Max( [1.0000000000000000000000001, 2.0000000000000000000000002], Value )
2.0000000000000000000000002

// decimal aware aggregate functions with mixed inputs -> float

>> Sum( 1.0000000000000000000000001, 2.0000000000000000000000002, Float(3))
6

>> Sum( [1.0000000000000000000000001, 2.0000000000000000000000002, Float(3)], Value )
6.0000000000000000000000003

>> Average( 1.0000000000000000000000001, 2.0000000000000000000000002, Float(3) )
2

>> Average( [1.0000000000000000000000001, 2.0000000000000000000000002, Float(3)], Value )
2.0000000000000000000000001

>> Min( 1.0000000000000000000000001, 2.0000000000000000000000002, Float(3) )
1

>> Min( [1.0000000000000000000000001, 2.0000000000000000000000002, Float(3)], Value )
1.0000000000000000000000001

>> Max( 1.0000000000000000000000001, 2.0000000000000000000000002, Float(3) )
3

>> Max( [1.0000000000000000000000001, 2.0000000000000000000000002, Float(3)], Value )
3

// non-decimal aware aggregate functions

>> VarP( 1.0000000000000000000000001, 2.0000000000000000000000002)
0.25

>> VarP( [1.0000000000000000000000001, 2.0000000000000000000000002], Value )
0.25

>> StdevP( 1.0000000000000000000000001, 2.0000000000000000000000002)
0.5

>> StdevP( [1.0000000000000000000000001, 2.0000000000000000000000002], Value )
0.5

// decimal aware numeric functions

>> Int( 1000000000000000000000001.1 )
1000000000000000000000001

>> Int( -1000000000000000000000001.1 )
-1000000000000000000000002

>> Int( [1000000000000000000000001.1, 2000000000000000000000002.2] )
Table({Value:1000000000000000000000001},{Value:2000000000000000000000002})

>> Int( [10000000000000000000000001, 20000000000000000000000002, Float(1)] )
Table({Value:10000000000000000000000001},{Value:20000000000000000000000002},{Value:1})

>> Trunc( 1000000000000000000000001.1 )
1000000000000000000000001

>> Trunc( [1000000000000000000000001.1, 2000000000000000000000002.2] )
Table({Value:1000000000000000000000001},{Value:2000000000000000000000002})

>> Trunc( [1000000000000000000000001.1, 2000000000000000000000002.2, Float(1)] )
Table({Value:1000000000000000000000001},{Value:2000000000000000000000002},{Value:1})

>> Round( 1000000000000000000000001.1, 2 )
1000000000000000000000001.1

>> Round( [1000000000000000000000001.1, 2000000000000000000000002.2], 2 )
Table({Value:1000000000000000000000001.1},{Value:2000000000000000000000002.2})

>> Round( 1000000000000000000000001.1, Float(2) )
1000000000000000000000001.1

>> Round( [1000000000000000000000001.1, 2000000000000000000000002.2], Float(2) )
Table({Value:1000000000000000000000001.1},{Value:2000000000000000000000002.2})

>> RoundUp( 1000000000000000000000001.1, 2 )
1000000000000000000000001.1

>> RoundUp( [1000000000000000000000001.1, 2000000000000000000000002.2], 2 )
Table({Value:1000000000000000000000001.1},{Value:2000000000000000000000002.2})

>> RoundUp( 1000000000000000000000001.1, Float(2) )
1000000000000000000000001.1

>> RoundUp( [1000000000000000000000001.1, 2000000000000000000000002.2], Float(2) )
Table({Value:1000000000000000000000001.1},{Value:2000000000000000000000002.2})

>> RoundDown( 1000000000000000000000001.1, 2 )
1000000000000000000000001.1

>> RoundDown( [1000000000000000000000001.1, 2000000000000000000000002.2], 2 )
Table({Value:1000000000000000000000001.1},{Value:2000000000000000000000002.2})

>> RoundDown( 1000000000000000000000001.1, Float(2) )
1000000000000000000000001.1

>> RoundDown( [1000000000000000000000001.1, 2000000000000000000000002.2], Float(2) )
Table({Value:1000000000000000000000001.1},{Value:2000000000000000000000002.2})

>> Abs( 10000000000000000000000001 )
10000000000000000000000001

>> Abs( -10000000000000000000000001 )
10000000000000000000000001

>> Abs( [10000000000000000000000001, 20000000000000000000000002, -10000000000000000000000001, -20000000000000000000000002])
Table({Value:10000000000000000000000001},{Value:20000000000000000000000002},{Value:10000000000000000000000001},{Value:20000000000000000000000002})

>> Abs( [10000000000000000000000001, 20000000000000000000000002, -10000000000000000000000001, -20000000000000000000000002, Float(1)])
Table({Value:10000000000000000000000001},{Value:20000000000000000000000002},{Value:10000000000000000000000001},{Value:20000000000000000000000002},{Value:1})

// non-decimal aware numeric functions

>> Sqrt( 1524157899404237160815376 )         // exact square of 1234567899876, should be done in float and match next test
1234567899876

>> Sqrt( Float(1524157899404237160815376) )  // exact square of 1234567899876
1234567899876

>> Sqrt( 4.000000000000000004 )              // outside of float range, will round to 4
2

>> Sqrt( 4.0000000004 )                      // within float range
2.0000000001

>> Log( 100, 10 )
2

>> Log( 10000000000000050000000, 10 )         // input will be rounded with float conversion
22

>> Log( 10000000000000050000000, Float(10) )
22

>> Log( 10000000000000000000000, 10 )         // above tests should match these answers
22

>> Log( 10000000000000000000000, Float(10) )  
22

>> Log( Float("1e100"), 10 )
100

// exp

// ln

>> Cos( 0 )
1

>> Cos( [0] )
Table({Value:1})

>> Sin( 0 )
0

>> Sin( [0] )
Table({Value:0})

// Cot

// Sin

// Tan

// Acos

// Acot

// Asin

// Atan

// Atan2

// Degrees

// Radians

>> Pi()
3.141592653589793

>> Power( 2.0000000000000000000000002, 2.0000000000000000000000002)
4

>> 2.0000000000000000000000002 ^ 2.0000000000000000000000002
4

// Decimal and Float functions

>> Value( 1e100 )
Errors: Error 7-12: Numeric value is too large.|Error 0-14: The function 'Value' has some invalid arguments.|Error 7-12: Expected text or number. We expect text or a number at this point in the formula.

>> Decimal( 1e100 )
Errors: Error 9-14: Numeric value is too large.|Error 0-16: The function 'Decimal' has some invalid arguments.|Error 9-14: Expected text or number. We expect text or a number at this point in the formula.

>> Float( 1e100 )
Errors: Error 7-12: Numeric value is too large.|Error 0-14: The function 'Float' has some invalid arguments.|Error 7-12: Expected text or number. We expect text or a number at this point in the formula.

>> Value( "1e100" )
Error({Kind:ErrorKind.InvalidArgument})

>> Decimal( "1e100" )
Error({Kind:ErrorKind.InvalidArgument})

>> Float( "1e100" )
1E+100

>> Value( true )
1

>> Decimal( true )
1

>> Float( true )
1

>> Decimal( "12,00000000000000000000003", "Fr-fr" )
12.00000000000000000000003

>> Float( "12,00000000000000000000003", "Fr-fr" )
12

>> Value( "12,00000000000000000000003", "Fr-fr" )
12.00000000000000000000003

>> Decimal( ParseJSON("""12,00000000000000000000003"""), "Fr-fr" )
12.00000000000000000000003

>> Float( ParseJSON("""12,00000000000000000000003"""), "Fr-fr" )
12

>> Value( ParseJSON("""12,00000000000000000000003"""), "Fr-fr" )
12.00000000000000000000003

// ParseJSON

>> Decimal( ParseJSON("12.00000000000000000000003") )
12.00000000000000000000003

>> Float( ParseJSON("12.00000000000000000000003") )
12

>> Value( ParseJSON("12.00000000000000000000003") )
12.00000000000000000000003

>> Decimal( Index( ParseJSON("[1e300,12.00000000000000000000003]"), 2 ) )
12.00000000000000000000003

>> Float( Index( ParseJSON("[1e300,12.00000000000000000000003]"), 2 ) )
12

>> Value( Index( ParseJSON("[1e300,12.00000000000000000000003]"), 2 ) )
12.00000000000000000000003

>> Decimal( ParseJSON("{""a"":12.00000000000000000000003}").a )
12.00000000000000000000003

>> Float( ParseJSON("{""a"":12.00000000000000000000003}").a )
12

>> Value( ParseJSON("{""a"":12.00000000000000000000003}").a )
12.00000000000000000000003

