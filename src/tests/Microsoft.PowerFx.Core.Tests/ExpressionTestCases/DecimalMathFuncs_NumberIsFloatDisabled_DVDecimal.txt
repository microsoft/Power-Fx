#SETUP: disable:NumberIsFloat,DecimalSupport

// DV Decimal: These tests are compabtible with the SQL compiler used by Dataverse, with a max/min of +/-100,000,000,000 and ten decimal places.  
// Variants of 10000000000.0000000001 are used which is not representable in floating point (rounds to 10000000000).  
// These tests are also runnable with the C# semantics for decimal which is why they are included in the Power-Fx repo, ensuring consistency between DV and C#.
// Where possible, unless specifically testing the C# range, should be written in the DV rnage.

// decimal aware aggregate functions

>> Sum( 10000000000.0000000001, 20000000000.0000000002)
30000000000.0000000003

>> Sum( [10000000000.0000000001, 20000000000.0000000002], Value )
30000000000.0000000003

>> Average( 10000000000.000000001, 20000000000.000000002 )
15000000000.0000000015

>> Average( [10000000000.000000001, 20000000000.000000002], Value )
15000000000.0000000015

>> Min( 10000000000.0000000001, 20000000000.0000000002 )
10000000000.0000000001

>> Min( [10000000000.0000000001, 20000000000.0000000002], Value )
10000000000.0000000001

>> Max( 10000000000.0000000001,20000000000.0000000002 )
20000000000.0000000002

>> Max( [10000000000.0000000001, 20000000000.0000000002], Value )
20000000000.0000000002

// decimal aware aggregate functions with mixed inputs -> first data type

>> Sum( 10000000000.0000000001, 20000000000.0000000002, Float(3))
30000000003.0000000003

>> Sum( [10000000000.0000000001, 20000000000.0000000002, Float(3)], Value )
30000000003.0000000003

>> Average( 10000000000.0000000001, 20000000000.0000000002, Float(3) )
10000000001.0000000001

>> Average( [10000000000.0000000001, 20000000000.0000000002, Float(3)], Value )
10000000001.0000000001

>> Min( 10000000000.0000000001, 20000000000.0000000002, Float(30000000000) )
10000000000.0000000001

>> Min( [10000000000.0000000001, 20000000000.0000000002, Float(30000000000)], Value )
10000000000.0000000001

>> Max( 10000000000.0000000001, 20000000000.0000000002, Float(-3) )
20000000000.0000000002

>> Max( [10000000000.0000000001, 20000000000.0000000002, Float(-3)], Value )
20000000000.0000000002

// non-decimal aware aggregate functions

>> VarP( 10000000000.0000000001, 20000000000.0000000002)
2.5E+19

>> VarP( [10000000000.0000000001, 20000000000.0000000002], Value )
2.5E+19

>> StdevP( 10000000000.0000000001, 20000000000.0000000002)
5000000000

>> StdevP( [10000000000.0000000001, 20000000000.0000000002], Value )
5000000000

>> VarP( 90000000000.0000000001, -90000000000.0000000002, Float(0) )
5.4E+21

>> Text( VarP( 10000000000.0000000001, 20000000000.0000000002, Float(30000000000) ), "##########E+00" )
"6666666667E+10"

>> Text( VarP( [10000000000.0000000001, 20000000000.0000000002, Float(30000000000)], Value ), "##########E+00" )
"6666666667E+10"

>> StdevP( 10000000000.0000000001, 20000000000.0000000002, Float(30000000000) )
8164965809.27726

>> StdevP( [10000000000.0000000001, 20000000000.0000000002, Float(30000000000)], Value )
8164965809.27726

// decimal aware numeric functions, stays on decimal

>> Int( 10000000001.0000000001 )
10000000001

>> Int( 10000000001.0000000001 ) + 10000000001.0000000001
20000000002.0000000001

>> Int( -10000000001.0000000001 )
-10000000002

>> Int( -10000000001.0000000001 ) + 20000000001.0000000001
9999999999.0000000001

>> Int( [10000000001.0000000001, 20000000002.0000000002] )
Table({Value:10000000001},{Value:20000000002})

>> Trunc(10000000001.0000000001)
10000000001

>> Trunc( [10000000001.0000000001, 20000000002.0000000002] )
Table({Value:10000000001},{Value:20000000002})

>> Round( 10000000001.0000000001, 10 )
10000000001.0000000001

>> Round( [10000000001.0000000001, 20000000002.0000000002], 10 )
Table({Value:10000000001.0000000001},{Value:20000000002.0000000002})

>> Round( 10000000001.0000000001, Float(10) )
10000000001.0000000001

>> Round( [10000000001.0000000001, 20000000002.0000000002], Float(10) )
Table({Value:10000000001.0000000001},{Value:20000000002.0000000002})

>> RoundUp( 10000000001.0000000001, 10 )
10000000001.0000000001

>> RoundUp( [10000000001.0000000001, 20000000002.0000000002], 10 )
Table({Value:10000000001.0000000001},{Value:20000000002.0000000002})

>> RoundUp( 10000000001.0000000001, Float(10) )
10000000001.0000000001

>> RoundUp( [10000000001.0000000001, 20000000002.0000000002], Float(10) )
Table({Value:10000000001.0000000001},{Value:20000000002.0000000002})

>> RoundDown( 10000000001.0000000001, 10 )
10000000001.0000000001

>> RoundDown( [10000000001.0000000001, 20000000002.0000000002], 10 )
Table({Value:10000000001.0000000001},{Value:20000000002.0000000002})

>> RoundDown( 10000000001.0000000001, Float(10) )
10000000001.0000000001

>> RoundDown( [10000000001.0000000001, 20000000002.0000000002], Float(10) )
Table({Value:10000000001.0000000001},{Value:20000000002.0000000002})

>> Abs( 10000000001.0000000001 )
10000000001.0000000001

>> Abs( -10000000001.0000000001 )
10000000001.0000000001

>> Abs( [10000000001.0000000001, 20000000002.0000000002, -10000000001.0000000001, -20000000002.0000000002])
Table({Value:10000000001.0000000001},{Value:20000000002.0000000002},{Value:10000000001.0000000001},{Value:20000000002.0000000002})

>> Abs( [10000000001.0000000001, 20000000002.0000000002, -10000000001.0000000001, -20000000002.0000000002, Float(-10000000001.0000000001)])
Table({Value:10000000001.0000000001},{Value:20000000002.0000000002},{Value:10000000001.0000000001},{Value:20000000002.0000000002},{Value:10000000001})

// decimal aware functions with mixed inputs

>> Int( [10000000001.0000000001, 20000000002.0000000002, Float(100000.12)] )
Table({Value:10000000001},{Value:20000000002},{Value:100000})

>> Trunc( [10000000001.0000000001, 20000000002.0000000002, Float(100000.12)] )
Table({Value:10000000001},{Value:20000000002},{Value:100000})

>> Round( [10000000001.0000000001, 20000000002.0000000002, Float(300000.1234)], 10 )
Table({Value:10000000001.0000000001},{Value:20000000002.0000000002},{Value:300000.1234})

>> Round( [10000000001.0000000101, 20000000002.0000000202, Float(300000.1234)], 8 )
Table({Value:10000000001.00000001},{Value:20000000002.00000002},{Value:300000.1234})

>> RoundUp( [10000000001.0000000101, 20000000002.0000000202, Float(300000.1234)], 10 )
Table({Value:10000000001.0000000101},{Value:20000000002.0000000202},{Value:300000.1234})

>> RoundDown( [10000000001.0000000101, 20000000002.0000000202, Float(300000.1234)], 10 )
Table({Value:10000000001.0000000101},{Value:20000000002.0000000202},{Value:300000.1234})

// these rounding tests are returning the correct results, due to the conversion between decimal and float

>> Int( [Float(100000.12), 10000000001.1000000101, 20000000002.9000000202, -10000000001.1000000101, -20000000002.9000000202] )
Table({Value:100000},{Value:10000000001},{Value:20000000002},{Value:-10000000002},{Value:-20000000003})

>> Trunc( [Float(100000.12), 10000000001.1000000101, 20000000002.9000000202, -10000000001.1000000101, -20000000002.9000000202] )
Table({Value:100000},{Value:10000000001},{Value:20000000002},{Value:-10000000001},{Value:-20000000002})

>> Round( [Float(100000.12), 10000000001.1000000101, 20000000002.9000000202, -10000000001.1000000101, -20000000002.9000000202], 10 )
Table({Value:100000.12},{Value:10000000001.1},{Value:20000000002.9},{Value:-10000000001.1},{Value:-20000000002.9})

>> RoundUp( [Float(100000.12), 10000000001.1000000101, 20000000002.9000000202, -10000000001.1000000101, -20000000002.9000000202], 10 )
Table({Value:100000.12},{Value:10000000001.1},{Value:20000000002.9},{Value:-10000000001.1},{Value:-20000000002.9})

>> RoundDown( [Float(100000.12), 10000000001.1000000101, 20000000002.9000000202, -10000000001.1000000101, -20000000002.9000000202], 10 )
Table({Value:100000.12},{Value:10000000001.1},{Value:20000000002.9},{Value:-10000000001.1},{Value:-20000000002.9})

>> Round( [Float(100000.12), 10000000001.1000000101, 20000000002.9000000202, -10000000001.1000000101, -20000000002.9000000202], 0 )
Table({Value:100000},{Value:10000000001},{Value:20000000003},{Value:-10000000001},{Value:-20000000003})

>> RoundUp( [Float(100000.12), 10000000001.1000000101, 20000000002.9000000202, -10000000001.1000000101, -20000000002.9000000202], 0 )
Table({Value:100001},{Value:10000000002},{Value:20000000003},{Value:-10000000002},{Value:-20000000003})

>> RoundDown( [Float(100000.12), 10000000001.1000000101, 20000000002.9000000202, -10000000001.1000000101, -20000000002.9000000202], 0 )
Table({Value:100000},{Value:10000000001},{Value:20000000002},{Value:-10000000001},{Value:-20000000002})

// non-decimal aware numeric functions

// exact square of 315345.1234512345 is 99442546884.47432701229957399
// taking square root of 99442546884.47433 should result in a difference between float and decimal
>> Sqrt( 99442546884.47432701229957399 )
315345.12345123454

>> Sqrt( Float(99442546884.47432701229957399) )
315345.12345123454

>> Sqrt( 4.000000000000000004 )              // outside of float range, will round to 4
2

>> Sqrt( 4.0000000004 )                      // within float range
2.0000000001

>> Log( 100, 10 )
2

>> Log( 10000000000.0000000001, 10 )        // input will be rounded with float conversion
10

>> Log( 10000000000.0000000001, Float(10) )
10

>> Log( 10000000000, 10 )         // above tests should match these answers
10

>> Log( 10000000000, Float(10) )  
10

>> Log( 10000000000.001, 10 )     // this test should be different
10.000000000000043

>> Log( Float("1e100"), 10 )
100

>> Ln( 2.71828182845904523536028747135266249775724709369995 )
1

>> Ln( 100000000 )
18.420680743952367

>> Exp( 18.420680743952367 )
100000000.00000007

>> Pi()
3.141592653589793

>> Cos( 0 )
1

>> Cos( [0] )
Table({Value:1})

>> Cos( Pi() )
-1

>> Cos( [Pi()] )
Table({Value:-1})

>> Sin( 0 )
0

>> Sin( [0] )
Table({Value:0})

>> Sin( Pi()/2 )
1

>> Cot( 0 )
Error({Kind:ErrorKind.Div0})

>> Cot( [0] )
Table({Value:Error({Kind:ErrorKind.Div0})})

>> Cot( 3.14159265358979323846264338327950288419716939937510 )
-8165619676597685

>> Cot( [3.14159265358979323846264338327950288419716939937510] )
Table({Value:-8165619676597685})

>> Cot( Pi()/4 )
1

>> Round( Cot( [Pi()/4] ), 10 )
Table({Value:1})

>> Tan( 0 )
0

>> Tan( [0] )
Table({Value:0})

>> Tan( Pi()/4 )
1

>> Round( Tan( [Pi()/4] ), 10 )
Table({Value:1})

>> Acos( 0 )
1.5707963267948966

>> Acos( [0] )
Table({Value:1.5707963267948966})

>> Acos( 1 )
0

>> Acos( [1] )
Table({Value:0})

>> Acot( 0 )
1.5707963267948966

>> Acot( [0] )
Table({Value:1.5707963267948966})

>> Acot( 1 )
0.7853981633974483

>> Acot( [1] )
Table({Value:0.7853981633974483})

>> Asin( 0 )
0

>> Asin( [0] )
Table({Value:0})

>> Asin( 1 )
1.5707963267948966

>> Asin( [1] )
Table({Value:1.5707963267948966})

>> Atan( 0 )
0

>> Atan( [0] )
Table({Value:0})

>> Atan( 1 )
0.7853981633974483

>> Atan( [1] )
Table({Value:0.7853981633974483})

>> 4 * Atan(1) - Pi()
0

>> Atan( [4 * Atan(1) - Pi()] )
Table({Value:0})

>> Atan2( 0, 0 )
Error({Kind:ErrorKind.Div0})

>> Atan2( 1, 1 )
0.7853981633974483

>> Degrees( Pi() )
180

>> Degrees( 3.14159265358979323846264338327950288419716939937510 )
180

>> Radians( 0 )
0

>> Radians( 180 )
3.141592653589793

>> Power( 2.0000000000000000000000002, 2.0000000000000000000000002)
4

>> 2.0000000000000000000000002 ^ 2.0000000000000000000000002
4

>> Power( 10000000000.0000000001, 2 )            // correctly beyond float range
1E+20

>> Power( 10000000000.00001, 2 )
1.000000000000002E+20

>> 10000000000.0000000001 ^ 2             // correctly beyond float range
1E+20

>> 10000000000.00001 ^ 2
1.000000000000002E+20

// Decimal and Float functions

>> Value( 1e100 )
Errors: Error 7-12: Numeric value is too large.|Error 0-14: The function 'Value' has some invalid arguments.|Error 7-12: Expected text or number. We expect text or a number at this point in the formula.

>> Decimal( 1e100 )
Errors: Error 9-14: Numeric value is too large.|Error 0-16: The function 'Decimal' has some invalid arguments.|Error 9-14: Expected text or number. We expect text or a number at this point in the formula.

>> Float( 1e100 )
Errors: Error 7-12: Numeric value is too large.|Error 0-14: The function 'Float' has some invalid arguments.|Error 7-12: Expected text or number. We expect text or a number at this point in the formula.

>> Value( "1e100" )
Error({Kind:ErrorKind.InvalidArgument})

>> Decimal( "1e100" )
Error({Kind:ErrorKind.InvalidArgument})

>> Value( true )
1

>> Decimal( true )
1

>> Float( true )
1

>> Decimal( "10000000000,0000000001", "Fr-fr" )
10000000000.0000000001

>> Float( "10000000000,0000000001", "Fr-fr" )
10000000000

>> Value( "10000000000,0000000001", "Fr-fr" )
10000000000.0000000001

>> Decimal( ParseJSON("""10000000000,0000000001"""), "Fr-fr" )
10000000000.0000000001

>> Float( ParseJSON("""10000000000,0000000001"""), "Fr-fr" )
10000000000

>> Value( ParseJSON("""10000000000,0000000001"""), "Fr-fr" )
10000000000.0000000001

// ParseJSON

>> Decimal( ParseJSON("10000000000.0000000001") )
10000000000.0000000001

>> Float( ParseJSON("10000000000.0000000001") )
10000000000

>> Value( ParseJSON("10000000000.0000000001") )
10000000000.0000000001

>> Decimal( Index( ParseJSON("[1e300,10000000000.0000000001]"), 2 ) )
10000000000.0000000001

>> Float( Index( ParseJSON("[1e300,10000000000.0000000001]"), 2 ) )
10000000000

>> Value( Index( ParseJSON("[1e300,10000000000.0000000001]"), 2 ) )
10000000000.0000000001

>> Decimal( ParseJSON("{""a"":10000000000.0000000001}").a )
10000000000.0000000001

>> Float( ParseJSON("{""a"":10000000000.0000000001}").a )
10000000000

>> Value( ParseJSON("{""a"":10000000000.0000000001}").a )
10000000000.0000000001

>> Round( 98765432198.1234567892, -2 )
98765432200

>> Round( 98765432198.1234567892, 2 )
98765432198.12

>> Round( 98765432198.1234567892, 100 )
98765432198.1234567892

>> Round( 98765432198.1234567892, -100 )
0

>> RoundUp( 98765432198.1234567892, -2 )
98765432200

>> RoundUp( 98765432198.1234567892, 2 )
98765432198.13

>> RoundUp( 98765432198.1234567892, 100 )
98765432198.1234567892

>> RoundUp( 98765432198.1234567892, -100 )
0

>> RoundDown( 98765432198.1234567892, -2 )
98765432100

>> RoundDown( 98765432198.1234567892, 2 )
98765432198.12

>> RoundDown( 98765432198.1234567892, 100 )
98765432198.1234567892

>> RoundDown( 98765432198.1234567892, -100 )
0


