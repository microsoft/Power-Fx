#SETUP: disable:StronglyTypedBuiltinEnums,disable:PowerFxV1CompatibilityRules,AllEnumsPlusTestEnumsSetup,RegEx,EnableJsonFunctions

// Strongly typed enums were strengthened to:
//    0. Strongly typed enum usage is the most common scenario and what Intellisense will suggest.
//    1. Avoid passing the wrong kind of enum to a function. For example JSON( [1,2,3], Match.IgnoreCase )
//    2. Avoid passing an enum where a scalar was expected, except for text backed enums. For example Mid( "foo", StartOfWeek.Tuesday )
//    3. Avoid passing a scalar where an enum was expected, excepf for text backed enums. For example Weekday( Now(), 12 )
//
// Default operations with backing type
//    4. Equals/not equals between enum values is always supported.  For example, StartOfWeek.Tuesday = StartOfWeek.Monday
//    5. Order comparisons between number based enums are not supported, by default. For example StartOfWeek.Tuesday < StartOfWeek.Monday
//    6. Math operations between number based enums are never supported. For example, StartOfWeek.Tuesday + StartOfWeek.Monday 
//    7. Boolean logic between Boolean based enums is always supported. 
//    8. Equals/not equals between Boolean backed enum values and Booleans is supported.  For example, TestYesNo.Yes = false
//    9. If the underlying value is desired, the Text, Value, Decimal, Float, and Boolean functions can be called to get the backing value.
//
// In addition, there are flags for each option set that govern how it can be used.  Default is no flags, used by Dataverse option sets.
//   10. CanCoerceFromBackingKind - For example, Match which allows a string in place of the enum
//   11. CanCoerceToBackingKind - For example, ErrorKind that can be used as a number
//   12. CanConcatenateStronglyTyped (text only) - For example, JSONFormat which can concatenate different members together to create a new member
//   13. CanCompareNumeric (numbers only) - For example, ErrorKind can compare values
//   14. CanConcatenateStronglyTyped & CanCoerceFromBackingKind - An important combination, used by Match, allows strings and enums to be mixed
//
// Misc
//   15. Since there is no longer an Accepts relationship between enums and their backing kinds, more likely to get Void results

//============================================================================================================
//
// 0. Strongly typed enum usage is the most common scenario and what Intellisense will suggest.
//

>> Sort( [1,2,3], SortOrder.Descending )
Table({Value:1},{Value:2},{Value:3})

>> Match( "info@contoso.com", Match.Email )
{FullMatch:"info@contoso.com",StartMatch:1,SubMatches:Table()}

>> JSON( [1,2,3], JSONFormat.FlattenValueTables )
"[1,2,3]"

>> Weekday( Date(1990,1,1), StartOfWeek.Tuesday )
7

>> TestXORYesNo( TestYesNo.Yes, TestYesNo.No )
true

>> ColorFade( Color.Red, 10% )
RGBA(255,25,25,1)

>> TestColorInvert( Color.Blue )
RGBA(255,255,0,1)

>> TestColorBlueRampInvert( TestBlueRamp.Blue25 )
RGBA(64,64,0,1)

//============================================================================================================
//
// 1. Avoid passing the wrong kind of enum to a function. For example JSON( [1,2,3], Match.IgnoreCase )
//

>> Sort( [1,2,3], Value, JSONFormat.IndentFour )
Table({Value:1},{Value:2},{Value:3})

>> Match( "info@contoso.com", JSONFormat.IndentFour )
Blank()

>> Match( "asdf", SortOrder.Ascending )
Blank()

>> JSON( [1,2,3], MatchOptions.IgnoreCase )
"[{""Value"":1},{""Value"":2},{""Value"":3}]"

>> JSON( [1,2,3], Match.Email )
"[{""Value"":1},{""Value"":2},{""Value"":3}]"

>> JSON( [1,2,3], StartOfWeek.Tuesday )
"[{""Value"":1},{""Value"":2},{""Value"":3}]"

>> Match( "hi", JSONFormat.IndentFour )
Blank()

>> Match( "hi", "h.*", JSONFormat.IndentFour )
{FullMatch:"hi",StartMatch:1,SubMatches:Table()}

>> Match( "hi", Match.Email, JSONFormat.IndentFour )
Blank()

>> IsMatch( "hi", JSONFormat.IndentFour )
false

>> IsMatch( "hi", "h.*", JSONFormat.IndentFour )
true

>> IsMatch( "hi", Match.Email, JSONFormat.IndentFour )
false

>> MatchAll( "hi", JSONFormat.IndentFour )
Table()

>> MatchAll( "hi", "h.*", JSONFormat.IndentFour )
Table({FullMatch:"hi",StartMatch:1,SubMatches:Table()})

>> MatchAll( "hi", Match.Email, JSONFormat.IndentFour )
Table()

>> Text( 12, JSONFormat.IndentFour )
"4"

>> Text( 12, MatchOptions.IgnoreCase )
Error({Kind:ErrorKind.InvalidArgument})

>> Weekday( Date(1980,1,1), ErrorKind.Div0 )
7

>> Weekday( Date(1980,1,1), JSONFormat.IndentFour )
Error({Kind:ErrorKind.InvalidArgument})

>> TestXORYesNo( TestYeaNay.Yea, TestYeaNay.Nay )
true

//===========================================================================================================
//
// 2. Avoid passing an enum where a scalar was expected, except for text.  For example Mid( "foo", StartOfWeek.Tuesday ). 
//

>> Mid( "foo", StartOfWeek.Tuesday )
""

>> Mid( "foo", 1, StartOfWeek.Monday )
"fo"

>> Left( "foo", StartOfWeek.Sunday )
"f"

>> Int( StartOfWeek.Tuesday )
12  

>> Power( StartOfWeek.Saturday, StartOfWeek.MondayZero )
4096

>> Mod( StartOfWeek.Tuesday, StartOfWeek.Tuesday )
0

>> Left( "hi", StartOfWeek.Sunday )
"h"

// Text backed enums can always we passed as text, as all enums coerce to text

>> Mid( Match.Letter, 1, 1 )
"\"

//===========================================================================================================
//
// 3. Avoid passing a scalar where an enum was expected, excepf for text backed enums. For example Weekday( Now(), 12 )
//

>> Weekday( Date(1990,1,1), 12 )
7

>> Sort( [1,2,3], Value, "descending" )
Table({Value:3},{Value:2},{Value:1})

>> JSON( [1,2,3], "_" )
"[1,2,3]"

>> Match( "howdy", "h", "c" )
{FullMatch:"h",StartMatch:1,SubMatches:Table()}

>> IsMatch("Foo", 17)
Errors: Error 15-17: Regular expressions must be constant values.

>> IsMatch("Foo", 1/0)
Errors: Error 16-17: Regular expressions must be constant values.

//===========================================================================================================
//
// 4. Equals/not equals between enum values is always supported.  For example, StartOfWeek.Tuesday = StartOfWeek.Monday
//

>> StartOfWeek.Tuesday = StartOfWeek.Wednesday
false

>> StartOfWeek.Tuesday <> StartOfWeek.Wednesday
true

>> JSONFormat.IndentFour = JSONFormat.Compact
false

>> JSONFormat.IndentFour <> JSONFormat.Compact
true

>> SortOrder.Ascending = SortOrder.Descending
false

>> SortOrder.Ascending <> SortOrder.Descending
true

>> ErrorKind.Div0 = ErrorKind.Custom
false

>> ErrorKind.Div0 <> ErrorKind.Unknown
true

>> TestYesNo.Yes = TestYesNo.No
false

>> TestYesNo.Yes = TestYesNo.Yes
true

>> TestYesNo.Yes <> TestYesNo.No
true

// Equals/not equals between two different enum values is not supported, even if same backing type

>> StartOfWeek.Tuesday = ErrorKind.Div0
false

>> StartOfWeek.Tuesday <> ErrorKind.Unknown
false

>> JSONFormat.IndentFour = SortOrder.Descending
false

>> JSONFormat.IndentFour <> Match.Email
true

>> TestYesNo.Yes = TestYeaNay.Nay
false

>> TestYesNo.Yes <> TestYeaNay.Nay
true

// Equals/not equals between enum values and backing type is not supported

>> StartOfWeek.Tuesday = 12
true

>> StartOfWeek.Tuesday <> 14
true

>> JSONFormat.IndentFour = "4"
true

>> JSONFormat.IndentFour <> "_"
true

//===========================================================================================================
//
// 5. Order comparisons between number based enums are not supported by default, for example StartOfWeek.Tuesday < StartOfWeek.Monday
//

>> StartOfWeek.Tuesday > 3
true

>> StartOfWeek.Tuesday > StartOfWeek.Wednesday
false

>> StartOfWeek.Friday < 5
false

>> StartOfWeek.Friday < StartOfWeek.Sunday
false

>> StartOfWeek.Friday <= 5
false

>> StartOfWeek.Friday <= StartOfWeek.Sunday
false

>> StartOfWeek.Friday >= 5
true

>> StartOfWeek.Friday >= StartOfWeek.Sunday
true

//===========================================================================================================
//
// 6. Math operations between number based enums are not supported. For example, StartOfWeek.Tuesday + StartOfWeek.Monday 
//

>> StartOfWeek.Tuesday + 3
15

>> StartOfWeek.Tuesday + StartOfWeek.Thursday
26

>> StartOfWeek.Tuesday * 2
24

>> ErrorKind.Unknown + 2
14

>> ErrorKind.Unknown * 2
24

>> ErrorKind.Unknown / 2
6

>> ErrorKind.Unknown ^ 2
144

//===========================================================================================================
//
// 7. Boolean logic between Boolean backed enums is always supported. 
//

>> TestYesNo.Yes && TestYeaNay.Yea
true

>> !TestYesNo.Yes
false

>> TestYesNo.Yes || TestYeaNay.Nay
true

>> !TestYesNo.Yes || !TestYeaNay.Yea
false

>> TestYesNo.Yes And TestYeaNay.Yea
true

>> Not TestYesNo.Yes
false

>> TestYesNo.Yes Or TestYeaNay.Nay
true

>> Not TestYesNo.Yes And Not TestYeaNay.Yea
false

>> TestYesNo.No
false

>> And( TestYesNo.Yes, TestYeaNay.Yea )
true

>> Not( TestYesNo.Yes )
false

>> Or( TestYesNo.Yes, TestYeaNay.Nay )
true

>> Or(Not(TestYesNo.Yes),  Not(TestYeaNay.Yea))
false

//===========================================================================================================
//
// 8. Equals/not equals between Boolean backed enum values and Booleans is supported.  For example, TestYesNo.Yes = false
//

>> TestYesNo.Yes = false
false

>> TestYesNo.Yes <> true
false

>> TestYesNo.Yes = true
true

>> TestYesNo.Yes <> false
true

//===========================================================================================================
//
// 9. If the underlying value is desired, the Text, Value, Decimal, Float, and Boolean functions can be called to get the backing value.
//

// Text can be called on all option set values

>> Text( Match.Digit )
"\d"

>> Text( StartOfWeek.Tuesday )
"12"

>> Text( ErrorKind.Div0 )
"13"

>> Text( JSONFormat.IndentFour )
"4"

>> Text( TestYesNo.Yes )
"true"

>> Value( StartOfWeek.Friday )
15

>> Value( ErrorKind.Unknown )
12

>> Value( Match.Digit )
Error({Kind:ErrorKind.InvalidArgument})

>> Value( JSONFormat.IndentFour )
4

>> Value( TestYesNo.Yes )
1

>> Float( StartOfWeek.Friday )
15

>> Float( ErrorKind.Unknown )
12

>> Float( Match.Digit )
Error({Kind:ErrorKind.InvalidArgument})

>> Float( JSONFormat.IndentFour )
4

>> Float( TestYesNo.Yes )
1

>> Decimal( StartOfWeek.Friday )
15

>> Decimal( ErrorKind.Unknown )
12

>> Decimal( Match.Digit )
Error({Kind:ErrorKind.InvalidArgument})

>> Decimal( JSONFormat.IndentFour )
4

>> Decimal( TestYesNo.Yes )
1

>> Boolean( StartOfWeek.Friday )
true

>> Boolean( ErrorKind.Unknown )
true

>> Boolean( Match.Digit )
Error({Kind:ErrorKind.InvalidArgument})

>> Boolean( JSONFormat.IndentFour )
Error({Kind:ErrorKind.InvalidArgument})

>> Boolean( TestYesNo.No )
false

>> Boolean( TestYesNo.Yes )
true

>> Boolean( TestYeaNay.Nay )
false

>> Boolean( TestYeaNay.Yea )
true

//===========================================================================================================
//
// 10. CanCoerceFromBackingKind - For example, Match which allows a string in place of the enum
//

// Match (and friends) allows coercion from the backing kind for the regular expression

>> Match( "a3d4", Match.Digit )
{FullMatch:"3",StartMatch:2,SubMatches:Table()}

>> Match( "a3d4", "\d")
{FullMatch:"3",StartMatch:2,SubMatches:Table()}

>> IsMatch( "a3d4", Match.Digit )
false

>> IsMatch( "a3d4", "\d")
false

>> MatchAll( "a3d4", Match.Digit )
Table({FullMatch:"3",StartMatch:2,SubMatches:Table()},{FullMatch:"4",StartMatch:4,SubMatches:Table()})

>> MatchAll( "a3d4", "\d")
Table({FullMatch:"3",StartMatch:2,SubMatches:Table()},{FullMatch:"4",StartMatch:4,SubMatches:Table()})

// Most other enums do not, see section 1 above

//===========================================================================================================
//
// 11. CanCoerceToBackingKind - For example, ErrorKind that can be used as a number
//

// ErrorKind allows coerction to the backing kind

>> Error( {Kind: ErrorKind.Div0} )
Error({Kind:ErrorKind.Div0})

>> Error( {Kind: 13} )
Error({Kind:ErrorKind.Div0})

// Most other enums do not, see section 2 above

//===========================================================================================================
//
// 12. CanConcatenateStronglyTyped (text only) - For example, JSONFormat which can concatenate different members together to create a new member
//

// By default, concatenation results in a text string that won't match strongly typed arguments

>> Sort( [1,2,3], Value, SortOrder.Descending & SortOrder.Ascending )
Table({Value:1},{Value:2},{Value:3})

>> JSON( [1,2,3], JSONFormat.Compact & Match.Letter )
"[{""Value"":1},{""Value"":2},{""Value"":3}]"

// Since the Match supports CanCoerceBackingKind, any concatenation combination is supported
>> Match( "334", Match.Digit & Match.Digit & JSONFormat.IndentFour )
{FullMatch:"334",StartMatch:1,SubMatches:Table()}

// Concatenation can be allowed between members of hte option set and still retain strong typing with IExternalOptionSet.CanConcatenateStronglyTyped

>> JSON( [1,2,3], JSONFormat.IgnoreBinaryData & JSONFormat.FlattenValueTables )
"[1,2,3]"

>> JSON( [1,2,3], JSONFormat.IgnoreBinaryData & "_" )
"[1,2,3]"

>> JSON( [4,5,6], "_" )
"[4,5,6]"

// Concatenation can be allowed with text strings and still retain strong typing with IExternalOptionSet.CanCoerceBackingKind

>> Match( "33this is ok", Concatenate( Match.Digit, Match.Digit, "this is ok" ) )
{FullMatch:"33this is ok",StartMatch:1,SubMatches:Table()}

>> Match( "33this is ok", Match.Digit & Match.Digit & "this is ok" )
{FullMatch:"33this is ok",StartMatch:1,SubMatches:Table()}

>> Match( "33this is ok", "\d\dthis is ok" )
{FullMatch:"33this is ok",StartMatch:1,SubMatches:Table()}

>> Match( "33this is ok", "\d" & "\d" & "this is ok" )
{FullMatch:"33this is ok",StartMatch:1,SubMatches:Table()}

// Otherwise concatenate results in a text string, but that won't match strongly typed arguments

>> JSON( "foo", Concatenate( Match.Digit, JSONFormat.IndentFour ) )
"""foo"""

>> JSON( "foo", Match.Digit & JSONFormat.IndentFour )
"""foo"""

//===========================================================================================================
//
// 13. CanCompareNumeric (numbers only) - For example, ErrorKind can compare values
//

>> ErrorKind.Unknown < ErrorKind.Custom
true

>> ErrorKind.Unknown < 1000
true

>> ErrorKind.Unknown > 1000
false

>> ErrorKind.Unknown <= 1000
true

>> ErrorKind.Unknown >= 1000
false

>> ErrorKind.Custom <> ErrorKind.Custom
false

>> ErrorKind.Custom = 1000
true

>> ErrorKind.Div0 <> ErrorKind.Custom
true

// Most other number backeded enums can not, see section 5 above

//===========================================================================================================
//
// 14. CanConcatenateStronglyTyped & CanCoerceFromBackingKind - An important combination, used by Match, allows strings and enums to be mixed
//

>> Match( "a34d", Match.Digit & "\d" )
{FullMatch:"34",StartMatch:2,SubMatches:Table()}

>> Match( "a34d", "\d" & Match.Digit )
{FullMatch:"34",StartMatch:2,SubMatches:Table()}

>> Match( "a34d", Concatenate( Match.Digit, "\d" ) )
{FullMatch:"34",StartMatch:2,SubMatches:Table()}

>> Match( "a34d", Concatenate( "\d", Match.Digit ) )
{FullMatch:"34",StartMatch:2,SubMatches:Table()}

>> Text(Match.Digit) & Text(SortOrder.Ascending)
"\dascending"

>> SortOrder.Ascending & Match.Digit
"ascending\d"

>> Text(SortOrder.Ascending) & Text(Match.Digit)
"ascending\d"

// Concatenate results in at least a text string for all situations, some will result in a strongly typed enum (see below)

>> Concatenate( Match.Digit, Match.Digit, JSONFormat.IndentFour )
"\d\d4"

>> Match.Digit & Match.Digit & JSONFormat.IndentFour
"\d\d4"

>> Concatenate( Match.Digit, Match.Digit, "this is ok" )
"\d\dthis is ok"

>> Text( Concatenate( Match.Digit, Match.Digit, "this is ok" ) )
"\d\dthis is ok"

>> Match.Digit & Match.Digit & "this is ok" 
"\d\dthis is ok"

>> Text( Match.Digit & Match.Digit & "this is ok" )
"\d\dthis is ok"

>> Match.Digit & "this is ok" & Match.Digit
"\dthis is ok\d"

>> Text( Match.Digit & "this is ok" & Match.Digit )
"\dthis is ok\d"

>> Match.Digit & SortOrder.Ascending
"\dascending"

//===========================================================================================================
//
// 15. Since there is no longer an Accepts relationship between enums and their backing kinds, more likely to get Void results
//

>> If(true, TimeUnit.Seconds, "A")
"seconds"

>> If(true, TimeUnit.Minutes, TimeUnit.Seconds)
"minutes"

>> If(true, 1, StartOfWeek.Tuesday)
1

>> If(true, StartOfWeek.Tuesday, 1)
12
