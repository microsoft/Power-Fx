#SETUP: disable:NumberIsFloat

// DV Decimal: These tests are compabtible with the SQL compiler used by Dataverse, with a max/min of +/-100,000,000,000 and ten decimal places.  
// Variants of 10000000000.0000000001 are used which is not representable in floating point (rounds to 10000000000).  
// These tests are also runnable with the C# semantics for decimal which is why they are included in the Power-Fx repo, ensuring consistency between DV and C#.
// Where possible, unless specifically testing the C# range, should be written in the DV rnage.

// non-decimal aware other functions

>> Mid( "asdf", 2, 2 )
"sd"

>> Left( "asdf", 1 )
"a"

>> Right( "asdf", 1 )
"f"

>> Count( [1,2,3,4] ) * 10000000000.0000000002
40000000000.0000000008

>> CountA( [1,2,3,4] ) * 10000000000.0000000002
40000000000.0000000008

>> CountRows( [1,2,3,4] ) * 10000000000.0000000002
40000000000.0000000008

>> Error({Kind:8})   // constraint violated
Error({Kind:ErrorKind.ConstraintViolated})

// generic functions that work with any data type

>> Filter( [10000000000.0000000001,10000000000.0000000002,10000000000.0000000003,10000000000.0000000002], Value = 10000000000.0000000002 )
Table({Value:10000000000.0000000002},{Value:10000000000.0000000002})

>> Filter( [{a:10000000000.0000000001,b:1},{a:10000000000.0000000002,b:2},{a:10000000000.0000000002,b:3},{a:10000000000.0000000004,b:4}], a = 10000000000.0000000002 )
Table({a:10000000000.0000000002,b:2},{a:10000000000.0000000002,b:3})

>> LookUp( [10000000000.0000000001,10000000000.0000000002,10000000000.0000000003,10000000000.0000000002], Value = 10000000000.0000000002 )
{Value:10000000000.0000000002}

>> LookUp( [{a:10000000000.0000000001,b:1},{a:10000000000.0000000002,b:2},{a:10000000000.0000000003,b:3},{a:10000000000.0000000004,b:4}], a = 10000000000.0000000002 )
{a:10000000000.0000000002,b:2}

>> ForAll([1,2,3],{Value:Value + 10000000000.0000000007})
Table({Value:10000000001.0000000007},{Value:10000000002.0000000007},{Value:10000000003.0000000007})

>> Sum(ForAll([1,2,3],{Value:Value}), Value + 10000000000.0000000007)
30000000006.0000000021

>> ForAll(["1","2","3"],{Value:Value + 10000000000.0000000007})
Table({Value:10000000001.0000000007},{Value:10000000002.0000000007},{Value:10000000003.0000000007})

>> Sum(ForAll(["1","2","3"],{Value:Value + 10000000000.0000000007}), Value + 10000000000.0000000007)
60000000006.0000000042

>> ForAll([Float(1),Float(2),Float(3)],{Value:Value + 10000000000.0000000007})
Table({Value:10000000001},{Value:10000000002},{Value:10000000003})

>> Table( {a:10000000001.0000000007},{b:10000000002.0000000007},{c:10000000003.0000000007} )
Table({a:10000000001.0000000007,b:Blank(),c:Blank()},{a:Blank(),b:10000000002.0000000007,c:Blank()},{a:Blank(),b:Blank(),c:10000000003.0000000007})

>> [10000000001.0000000007,20000000002.0000000008,30000000003.0000000009]
Table({Value:10000000001.0000000007},{Value:20000000002.0000000008},{Value:30000000003.0000000009})

// based on first type rule, a is decimal, b is float
>> Table( {a:10000000001.0000000007,b:Float(2)},{a:Float(1),b:20000000002.0000000008} )
Table({a:10000000001.0000000007,b:2},{a:1,b:20000000002})

>> [{a:10000000001.0000000007,b:Float(2)},{a:Float(1),b:20000000002.0000000008}]
Table({a:10000000001.0000000007,b:2},{a:1,b:20000000002})

// functions that take their type from the first instance of the value

>> If( true, 10000000001.0000000007, Float(1) )
10000000001.0000000007

>> If( false, 10000000001.0000000007, Float(1) )
1

>> If( true, 10000000001.0000000007, Float(1) ) + 10340000001.0000000007
20340000002.0000000014

>> If( false, 10000000001.0000000007, Float(1) ) + 10340000001.0000000007
10340000002.0000000007

>> If( true, 10000000001.0000000007, 20000000001.0000000009 )
10000000001.0000000007

>> If( false, 10000000001.0000000007, 20000000001.0000000009 )
20000000001.0000000009

>> If( true, 10000000001.0000000007, "20000000001.0000000009" )
10000000001.0000000007

>> If( false, 10000000001.0000000007, "20000000001.0000000009" )
20000000001.0000000009

>> If( true, 10000000001.0000000007, false )
10000000001.0000000007

>> If( false, 10000000001.0000000007, false )
0

>> If( true, 10000000001.0000000007, false ) + 20034000001.0000000009
30034000002.0000000016

>> If( false, 10000000001.0000000007, false ) + 20034000001.0000000009
20034000001.0000000009

>> If( true, 10000000001.0000000007, Float("1e100") )
10000000001.0000000007

>> If( false, 10000000001.0000000007, Float("1e100") )
Error({Kind:ErrorKind.InvalidArgument})

>> If( 1, 2, 3 )
2

>> If( 10000000001.0000000007 - 1, 2, 3 )
2

>> Switch( 10000000001.0000000002, 10000000001.0000000001, "no1", 10000000001.0000000002, "yes", 1.0000000000000000000000003, "no2", "no3" ) 
"yes"

>> Switch( 10000000001.0000000002, 10000000001.0000000001, 20000000001.0000000001, 10000000001.0000000002, 20000000001.0000000002, 10000000001.0000000003, 20000000001.0000000003, 20000000001.0000000004 )
20000000001.0000000002

>> Switch( 10000000001.0000000002, 10000000001.0000000001, 20000000001.0000000001, 10000000001.0000000002, "20000000001.0000000002", 10000000001.0000000003, 20000000001.0000000003, 20000000001.0000000004 )
20000000001.0000000002

>> Switch( 10000000001.0000000005, 10000000001.0000000001, 20000000001.0000000001, 20000000001.0000000001, 20000000001.0000000002, 10000000001.0000000003, 20000000001.0000000003, 20000000001.0000000004 )
20000000001.0000000004

>> Switch( "1", "1",  20000000001.0000000001, "2",  20000000001.0000000002, "3",  20000000001.0000000003,  20000000001.0000000004 )
20000000001.0000000001

>> Switch( false, 1, 20000000001.0000000001, 0, 20000000001.0000000002, 3, 20000000001.0000000003, 20000000001.0000000004 )
#SKIP waiting on https://github.com/microsoft/Power-Fx/issues/1251, expected: 2.0000000000000000000000002

>> Switch( "4", "1", 20000000001.0000000001, "2", 20000000001.0000000002, "3", 20000000001.0000000003, 20000000001.0000000004 )
20000000001.0000000004

>> Switch( "10000000001.0000000001", 10000000001.0000000001, 20000000001.0000000001, 10000000001.0000000002, 20000000001.0000000002, 10000000001.0000000003, 20000000001.0000000003, 20000000001.0000000004 )
#SKIP waiting on https://github.com/microsoft/Power-Fx/issues/1251, expected: 20000000001.0000000001

>> Switch( "10000000001.0000000005", 10000000001.0000000001, 20000000001.0000000001, 10000000001.0000000002, 20000000001.0000000002, 10000000001.0000000003, 20000000001.0000000003, 20000000001.0000000004 )
#SKIP waiting on https://github.com/microsoft/Power-Fx/issues/1251, expected: 20000000001.0000000004

>> Switch( "0", true, 20000000001.0000000001, false, 20000000001.0000000002, 20000000001.0000000004 )
#SKIP waiting on https://github.com/microsoft/Power-Fx/issues/1251

>> Coalesce( 20000000001.0000000001, 40000000001.0000000001 )
20000000001.0000000001

>> Coalesce( Decimal(Blank()), 40000000001.0000000001 )
40000000001.0000000001

>> Coalesce( If( 1<0, 20000000001.0000000001 ), 40000000001.0000000001 ) 
40000000001.0000000001

>> Coalesce( 20000000001.0000000002, Float(4) ) + 40000000001.0000000001 
60000000002.0000000003

>> Coalesce( Decimal(Blank()), Float(4) ) + 40000000001.0000000001 
40000000005.0000000001 

>> Coalesce( If( 1<0, 20000000001.0000000002 ), Float(4) ) + 40000000001.0000000001 
40000000005.0000000001

>> IfError( 20000000001.0000000002, 40000000001.0000000001 )
20000000001.0000000002

>> IfError( 20000000001.0000000002/0, 40000000001.0000000001 )
40000000001.0000000001

>> IfError( Float(2)/0, 40000000001.0000000001 )
40000000001

>> IfError( 20000000001.0000000002/0, Float(4) ) + 40000000001.0000000001 
40000000005.0000000001 

>> Text( 1.234567890123456789012345678912345 )
"1.2345678901234567890123456789"

>> Text( 98765432198.7654321987, "#,###.0000000000000000" )
"98,765,432,198.7654321987000000"

>> Text( 98765432198.7654321987, "#,###.00" )
"98,765,432,198.77"

>> Text( -98765432198.7654321987, "0" )
"-98765432199"

>> Text( 98765432198.7654321987, "0" )
"98765432199"

// These tests with % result in a number beyond the range of DV decimal, however it is only for string output and considered formatting, not numeric

>> Text( 987654321.9817654321987, "0%" )
"98765432198%"

>> Text( -9876543219.87654321987, "0%" )
"-987654321988%"

>> Text( -9876543219.87654321987, "0%%%" )
"-9876543219876543%%%"

>> Text( -9876543219.87654321987, "0%%%%%" )
"-98765432198765432199%%%%%"

>> Text( -98765432198.7654321987, "0000000000000000000" )
"-0000000098765432199"

>> Text( 98765432198.7654321987, "0000000000000000000" )
"0000000098765432199"

>> Text( -98765432198.7654321987, "0.0000000000000000000" )
"-98765432198.7654321987000000000"

>> Text( 98765432198.7654321987, "0.0000000000000000000" )
"98765432198.7654321987000000000"

>> Text( 98765432198.7654321987, "00000000000e0" )
"98765432199e0"

>> Text( 98765432198.7654321987, "0e0" )
"1e11"

>> Text( 12345, "mm-dd-yyyy")
"10-18-1933"

>> Text( 123456789, "00000-0000" )
"12345-6789"

>> Text( "123456789", "00000-0000" )
Errors: Error 0-33: The function 'Text' has some invalid arguments.|Warning 19-31: The second argument of the 'Text' function is only supported for numeric and date/time values.

// strings should pass straight through, second argument no longer allowed

>> Text( ".1234567890123456789012345678912345" )
".1234567890123456789012345678912345"

>> Text( "1234567890123456789012345678912345" )
"1234567890123456789012345678912345"

>> Text( ".1234567890123456789012345678912345", "0.0000000000000000000000000000000e00" )
Errors: Error 0-85: The function 'Text' has some invalid arguments.|Warning 45-83: The second argument of the 'Text' function is only supported for numeric and date/time values.

>> Text( ".1234567890123456789012345678912345", "00.0000000000000000000000000000000000%" )
Errors: Error 0-87: The function 'Text' has some invalid arguments.|Warning 45-85: The second argument of the 'Text' function is only supported for numeric and date/time values.

>> Text( ParseJSON("1.234567890123456789012345678"), "0.000000000000e00" )
"1.234567890123e00"

>> Text( ParseJSON("1.234567890123456789012345678"), "00.0000000000000%" )
"123.4567890123457%"

>> Text( ParseJSON("1.234567890123456789012345678") )
"1.234567890123456789012345678"

>> Text( ParseJSON("3.1415e300") )
"3.1415e300"

>> Text( ParseJSON("3.1415E300") )
"3.1415E300"

>> Text( ParseJSON("3.1415e-300") )
"3.1415e-300"

>> Text( ParseJSON("3.1415E+300") )
"3.1415E+300"

>> Text( ParseJSON("123456789"), "00000-0000" )
"12345-6789"

>> Text( ParseJSON("1234.34534554e20") )
"1234.34534554e20"

>> Text( ParseJSON("1234.34534554e2000") )
"1234.34534554e2000"

// badly formed numbers

>> Text( ParseJSON("123456789d12") )
Error({Kind:ErrorKind.InvalidArgument})

>> Text( ParseJSON("--123456789") )
Error({Kind:ErrorKind.InvalidArgument})
