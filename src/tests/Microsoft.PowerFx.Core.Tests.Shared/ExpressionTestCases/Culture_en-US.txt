#SETUP: RegEx,CultureInfo("en-US"),PowerFxV1CompatibilityRules,ConsistentOneColumnTableResult,SupportColumnNamesAsIdentifiers

// Compared against tr-TR here, as that is one of the harder languages to get right. This should NOT be the case in en-US:
//     Four types of letter I
//            Dotted     Dotless
//     Upper  İ U+0130   I U+0049
//     Lower  i U+0069   ı U+0131

>> Language()
"en-US"

>> "İ" = UniChar( Hex2Dec( "0130") )
true

>> "ı" = UniChar( Hex2Dec( "0131" ) )
true

// UPPER, LOWER, PROPER

>> Upper( "i" )
"I"

>> Lower( "I" )
"i"

>> Upper( "i" ) = "I"
true

>> Lower( "I" ) = "i"
true

>> Lower( "quit" ) = Lower( "QUIT" )
true

>> Lower( "quit" ) = Lower( "QUİT" )
true

>> Lower( "quıt" ) = Lower( "QUIT" )
false

>> Upper( "quit" ) = Upper( "QUIT" )
true

>> Proper( "Iabc" )
"Iabc"

>> Proper( "iabc" )
"Iabc"

// VALUE, DECIMAL, FLOAT

>> Value( "123,456" )
123456

>> Value( "123,456", "tr-TR" )
123.456

>> Decimal( "123,456" )
123456

>> Decimal( "123,456", "tr-TR" )
123.456

>> Float( "123,456" )
123456

>> Float( "123,456", "tr-TR" )
123.456

// TEXT

>> Text( DateTime(2010,1,1,14,0,0,0), "mmm ddd yyyy AM/PM" )
"Jan Fri 2010 PM"

>> Text( DateTime(2020,1,1,2,0,0,0), "mmmm dddd yyyy AM/PM" )
"January Wednesday 2020 AM"

>> Text( 123456789, "#,###.00" )
"123,456,789.00"

>> Text( 123456789, "#.###,00" )
"123456789.00000"

// IN AND EXACTIN

>> "i" in "SIGH"
true

>> "I" in "sigh"
true

>> "i" exactin "SIGH"
false

>> "I" exactin "sigh"
false

>> "I" exactin "SIGH"
true

>> "i" exactin "sigh"
true

>> "sIGh" in ["sigh","bcde"]
true

>> "siGh" in ["SIGH","bcde"]
true

>> "sIGH" in ["sigh","bcde"]
true

>> "siGH" in ["bcde","sIgh"]
true

>> "SIgh" in ["bcde","sigh"]
true

// SORT

>> Concat( Sort( Split( "U m F M Z A j K P N k v C D T R V B u p a t c l G o f O J y I d i S b H e s z g Y h E r L n", " " ), Value ), Value, " " )
"a A b B c C d D e E f F g G h H i I j J k K l L m M n N o O p P r R s S t T u U v V y Y z Z"

>> Concat( SortByColumns( Split( "M v E H h t Z n V l Y O N r C z D K R G U j o I b y p k a e S d A F g s B L m c T P f u J i", " " ), "Value" ), Value, " " )
"a A b B c C d D e E f F g G h H i I j J k K l L m M n N o O p P r R s S t T u U v V y Y z Z"

// tr-TR alphabet, should not necessarily match

>> "         " & Concat( Sort( Split( "j J k K l L m M n N o O p P r R s S t T u U v V y Y z Z Ç ç Ş ş Ü ü Ö ö İ ı Ğ ğ a A b B c C d D e E f F g G h H i I", " " ), Value ), Value, " " )
"         a A b B c C ç Ç d D e E f F g G ğ Ğ h H i I İ ı j J k K l L m M n N o O ö Ö p P r R s S ş Ş t T u U ü Ü v V y Y z Z"
// tr-TR: a A b B c C ç Ç d D e E f F g G ğ Ğ h H ı I i İ j J k K l L m M n N o O ö Ö p P r R s S ş Ş t T u U ü Ü v V y Y z Z

>> "         " & Concat( SortByColumns( Split( "d D e E f F g G h H i I j J k K l L m M n N o O p P r R s S t T u U v V y Y z Z Ç ç Ş ş Ü ü Ö ö İ ı Ğ ğ a A b B c C", " " ), "Value" ), Value, " " )
"         a A b B c C ç Ç d D e E f F g G ğ Ğ h H i I İ ı j J k K l L m M n N o O ö Ö p P r R s S ş Ş t T u U ü Ü v V y Y z Z"
// tr-TR: a A b B c C ç Ç d D e E f F g G ğ Ğ h H ı I i İ j J k K l L m M n N o O ö Ö p P r R s S ş Ş t T u U ü Ü v V y Y z Z

// da-DK alphabet, should not necessarily match

>> "         " & Concat( Sort( Split( "n F X W o i j x B m I R G S h Ø L p K t A k l y J æ u v s T a ø N D z Æ e O U E H r Z å g b q Å P d f C M c Y w V Q", " " ), Value ), Value, " " )
"         a A å Å æ Æ b B c C d D e E f F g G h H i I j J k K l L m M n N o O ø Ø p P q Q r R s S t T u U v V w W x X y Y z Z"
// da-DK: A a B b C c D d E e F f G g H h I i J j K k L l M m N n O o P p Q q R r S s T t U u V v W w X x Y y Z z Æ æ Ø ø Å å

>> "         " & Concat( SortByColumns( Split( "U c q s X Å P L i I u d J å M E l k W v j Æ n a B K C D e ø æ f O y m Ø r Q R A x h T H N Z F V w o S g t p G Y b z", " " ), "Value" ), Value, " " )
"         a A å Å æ Æ b B c C d D e E f F g G h H i I j J k K l L m M n N o O ø Ø p P q Q r R s S t T u U v V w W x X y Y z Z"
// da-DK: A a B b C c D d E e F f G g H h I i J j K k L l M m N n O o P p Q q R r S s T t U u V v W w X x Y y Z z Æ æ Ø ø Å å

// sv-SE alphabet, should not necessarily match

>> "         " & Concat( Sort( Split( "H C å n N P X c j F Q O r A D s L ä K t b ö g k Ö z m l x U e y w S Å f p I Y W Z J B o u d G v E T i R Ä V a q M h", " " ), Value ), Value, " " )
"         a A å Å ä Ä b B c C d D e E f F g G h H i I j J k K l L m M n N o O ö Ö p P q Q r R s S t T u U v V w W x X y Y z Z"
// sv-SE: a A b B c C d D e E f F g G h H i I j J k K l L m M n N o O p P q Q r R s S t T u U v V w W x X y Y z Z å Å ä Ä ö Ö

>> "         " & Concat( SortByColumns( Split( "B I Ö p M Y h a A X V w z J Z t l k x G Ä e f v y T W E i Å R N Q K n C u F b H L q c r d m g o S j O P å D U ö s ä", " " ), "Value" ), Value, " " )
"         a A å Å ä Ä b B c C d D e E f F g G h H i I j J k K l L m M n N o O ö Ö p P q Q r R s S t T u U v V w W x X y Y z Z"
// sv-SE: a A b B c C d D e E f F g G h H i I j J k K l L m M n N o O p P q Q r R s S t T u U v V w W x X y Y z Z å Å ä Ä ö Ö

// REGULAR EXPRESSIONS
// C# invariant culture is always used, even thgouth tr-TR is set.  This is an industry standard for regular expressions, somewhat to prevent differences matching system strings (such as file name parsing).

// Results when using C#                                  // Invariant   tr-TR    en-US

>> IsMatch( "İ", "i", MatchOptions.IgnoreCase )           // false       TRUE     TRUE
false

>> IsMatch( "i", "İ", MatchOptions.IgnoreCase )           // false       TRUE     TRUE
false

>> IsMatch( "ı", "I", MatchOptions.IgnoreCase )           // false       TRUE     false
false

>> IsMatch( "I", "ı", MatchOptions.IgnoreCase )           // false       TRUE     false
false

>> IsMatch( "İ", "I", MatchOptions.IgnoreCase )           // false       false    TRUE
false

>> IsMatch( "I", "İ", MatchOptions.IgnoreCase )           // false       false    TRUE
false

>> IsMatch( "ı", "i", MatchOptions.IgnoreCase )           // false       false    false
false

>> IsMatch( "i", "ı", MatchOptions.IgnoreCase )           // false       false    false
false

>> IsMatch( "i", "I", MatchOptions.IgnoreCase )           // TRUE        false    TRUE
true

>> IsMatch( "I", "i", MatchOptions.IgnoreCase )           // TRUE        false    TRUE
true

>> IsMatch( "ı", "İ", MatchOptions.IgnoreCase )           // false       false    false
false

>> IsMatch( "İ", "ı", MatchOptions.IgnoreCase )           // false       false    false
false

>> ShowColumns( Match( "hiIıİİıIhi", "\u0130+" ), FullMatch, StartMatch )
{FullMatch:"İİ",StartMatch:5}

>> IsMatch( "Sıgh", "\u0131", MatchOptions.Contains )
true
