// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.PowerFx.Intellisense;
using Microsoft.PowerFx.LanguageServerProtocol;
using Microsoft.PowerFx.LanguageServerProtocol.Protocol;
using Microsoft.PowerFx.Types;
using Xunit;

namespace Microsoft.PowerFx.Tests.LanguageServiceProtocol
{
    public partial class LanguageServerTestBase
    {
        private async Task TestPublishDiagnostics(string uri, string method, string formula, Diagnostic[] expectedDiagnostics)
        {
            var payload = GetDidOpenPayload(new DidOpenTextDocumentParams()
            {
                TextDocument = new TextDocumentItem()
                {
                    Uri = uri,
                    LanguageId = "powerfx",
                    Version = 1,
                    Text = formula
                }
            });
            var rawResponse = await TestServer.OnDataReceivedAsync(payload).ConfigureAwait(false);
            var notification = GetDiagnosticsParams(rawResponse);
            Assert.Equal(uri, notification.Uri);
            Assert.Equal(expectedDiagnostics.Length, notification.Diagnostics.Length);

            var diagnosticsSet = new HashSet<Diagnostic>(expectedDiagnostics);
            for (var i = 0; i < expectedDiagnostics.Length; i++)
            {
                var expectedDiagnostic = expectedDiagnostics[i];
                var actualDiagnostic = notification.Diagnostics[i];
                Assert.True(diagnosticsSet.Where(x => x.Message == actualDiagnostic.Message).Count() == 1);
                diagnosticsSet.RemoveWhere(x => x.Message == actualDiagnostic.Message);
            }

            Assert.True(diagnosticsSet.Count() == 0);
        }

        [Theory]
        [InlineData("A+CountRows(B)", "{\"A\":1,\"B\":[1,2,3]}")]
        public async Task TestDidOpenValidFormula(string formula, string context = null)
        {
            var uri = $"powerfx://app{(context != null ? "powerfx://app?context=" + context : string.Empty)}";
            await TestPublishDiagnostics(uri, "textDocument/didOpen", formula, new Diagnostic[0]).ConfigureAwait(false);
        }

        [Theory]
        [InlineData("AA", "Name isn't valid. 'AA' isn't recognized.")]
        [InlineData("1+CountRowss", "Name isn't valid. 'CountRowss' isn't recognized.")]
        [InlineData("CountRows(2)", "Invalid argument type (Decimal). Expecting a Table value instead.", "The function 'CountRows' has some invalid arguments.")]
        public async Task TestDidOpenErroneousFormula(string formula, params string[] expectedErrors)
        {
            var expectedDiagnostics = expectedErrors.Select(error => new Diagnostic()
            {
                Message = error,
                Severity = DiagnosticSeverity.Error
            }).ToArray();
            await TestPublishDiagnostics("powerfx://app", "textDocument/didOpen", formula, expectedDiagnostics).ConfigureAwait(false);
        }

        [Fact]
        public async Task TestDidOpenSeverityFormula()
        {
            var formula = "Count([\"test\"])";
            var expectedDiagnostics = new[]
            {
                new Diagnostic()
                {
                    Message = "Invalid schema, expected a column of Number values for 'Value'.",
                    Severity = DiagnosticSeverity.Warning
                },
                new Diagnostic()
                {
                    Message = "The function 'Count' has some invalid arguments.",
                    Severity = DiagnosticSeverity.Error
                },
            };
            await TestPublishDiagnostics("powerfx://app", "textDocument/didOpen", formula, expectedDiagnostics).ConfigureAwait(false);
        }

        [Theory]
        [InlineData("Concatenate(", 12, false, false)]
        [InlineData("Behavior(); Concatenate(", 24, true, false)]
        [InlineData("Behavior(); Concatenate(", 24, false, true)]
        public async Task TestDidOpenWithErrors(string text, int offset, bool withAllowSideEffects, bool expectBehaviorError)
        {
            Init(new InitParams(options: GetParserOptions(withAllowSideEffects)));
            var payload = GetDidOpenPayload(new DidOpenTextDocumentParams()
            {
                TextDocument = new TextDocumentItem()
                {
                    Uri = "powerfx://app",
                    LanguageId = "powerfx",
                    Version = 1,
                    Text = text
                }
            }); 
            var rawResponse = await TestServer.OnDataReceivedAsync(payload).ConfigureAwait(false);
            CheckBehaviorError(rawResponse, expectBehaviorError, out var diags);

            var diag = diags.First(d => d.Message == "Unexpected characters. The formula contains 'Eof' where 'ParenClose' is expected.");

            Assert.Equal(offset, diag.Range.Start.Character);
            Assert.Equal(offset, diag.Range.End.Character);
        }

        [Theory]
        [InlineData("A+CountRows(B)", 3, false, false)]
        [InlineData("Behavior(); A+CountRows(B)", 4, true, false)]
        [InlineData("Behavior(); A+CountRows(B)", 4, false, true)]
        public async Task TestPublishTokens(string text, int count, bool withAllowSideEffects, bool expectBehaviorError)
        {
            Init(new InitParams(options: GetParserOptions(withAllowSideEffects)));

            // getTokensFlags = 0x0 (none), 0x1 (tokens inside expression), 0x2 (all functions)
            var documentUri = "powerfx://app?context={\"A\":1,\"B\":[1,2,3]}&getTokensFlags=1";
            var payload = GetDidOpenPayload(new DidOpenTextDocumentParams()
            {
                TextDocument = new TextDocumentItem()
                {
                    Uri = documentUri,
                    LanguageId = "powerfx",
                    Version = 1,
                    Text = text
                }
            });

            var rawResponse = await TestServer.OnDataReceivedAsync(payload).ConfigureAwait(false);
            var response = GetPublishTokensParams(rawResponse);
            Assert.Equal(documentUri, response.Uri);
            Assert.Equal(count, response.Tokens.Count);
            Assert.Equal(TokenResultType.Variable, response.Tokens["A"]);
            Assert.Equal(TokenResultType.Variable, response.Tokens["B"]);
            Assert.Equal(TokenResultType.Function, response.Tokens["CountRows"]);

            CheckBehaviorError(rawResponse, expectBehaviorError, out _);

            if (count == 4)
            {
                Assert.Equal(TokenResultType.Function, response.Tokens["Behavior"]);
            }

            // getTokensFlags = 0x0 (none), 0x1 (tokens inside expression), 0x2 (all functions)
            documentUri = "powerfx://app?context={\"A\":1,\"B\":[1,2,3]}&getTokensFlags=2";
            payload = GetNotificationPayload(
                new DidChangeTextDocumentParams()
            {
                TextDocument = new VersionedTextDocumentIdentifier()
                {
                    Uri = documentUri,
                    Version = 1,
                },
                ContentChanges = new TextDocumentContentChangeEvent[]
                {
                    new TextDocumentContentChangeEvent() { Text = text }
                }
            }, TextDocumentNames.DidChange);

            rawResponse = await TestServer.OnDataReceivedAsync(payload).ConfigureAwait(false);
            response = GetPublishTokensParams(rawResponse);

            Assert.Equal(documentUri, response.Uri);
            Assert.Equal(0, Enumerable.Count(response.Tokens.Where(it => it.Value != TokenResultType.Function)));
            Assert.Equal(TokenResultType.Function, response.Tokens["Abs"]);
            Assert.Equal(TokenResultType.Function, response.Tokens["Clock.AmPm"]);
            Assert.Equal(TokenResultType.Function, response.Tokens["CountRows"]);
            Assert.Equal(TokenResultType.Function, response.Tokens["VarP"]);
            Assert.Equal(TokenResultType.Function, response.Tokens["Year"]);

            CheckBehaviorError(rawResponse, expectBehaviorError, out _);

            // getTokensFlags = 0x0 (none), 0x1 (tokens inside expression), 0x2 (all functions)
            documentUri = "powerfx://app?context={\"A\":1,\"B\":[1,2,3]}&getTokensFlags=3";
            payload = GetNotificationPayload(
                    new DidChangeTextDocumentParams()
                    {
                        TextDocument = new VersionedTextDocumentIdentifier()
                        {
                            Uri = documentUri,
                            Version = 1,
                        },
                        ContentChanges = new TextDocumentContentChangeEvent[]
                        {
                            new TextDocumentContentChangeEvent() { Text = text }
                        }
                    }, TextDocumentNames.DidChange);

            rawResponse = await TestServer.OnDataReceivedAsync(payload).ConfigureAwait(false);
            response = GetPublishTokensParams(rawResponse);

            Assert.Equal(documentUri, response.Uri);
            Assert.Equal(TokenResultType.Variable, response.Tokens["A"]);
            Assert.Equal(TokenResultType.Variable, response.Tokens["B"]);
            Assert.Equal(TokenResultType.Function, response.Tokens["Abs"]);
            Assert.Equal(TokenResultType.Function, response.Tokens["Clock.AmPm"]);
            Assert.Equal(TokenResultType.Function, response.Tokens["CountRows"]);
            Assert.Equal(TokenResultType.Function, response.Tokens["VarP"]);
            Assert.Equal(TokenResultType.Function, response.Tokens["Year"]);

            CheckBehaviorError(rawResponse, expectBehaviorError, out _);
        }

        [Theory]
        [InlineData("{\"A\": 1 }", "A+2", typeof(DecimalType))]
        [InlineData("{}", "\"hi\"", typeof(StringType))]
        [InlineData("{}", "", typeof(BlankType))]
        [InlineData("{}", "{ A: 1 }", typeof(KnownRecordType))]
        [InlineData("{}", "[1, 2, 3]", typeof(TableType))]
        [InlineData("{}", "true", typeof(BooleanType))]
        public async Task TestPublishExpressionType(string context, string expression, System.Type expectedType)
        {
            var documentUri = $"powerfx://app?context={context}&getExpressionType=true";
            var payload = GetDidOpenPayload(new DidOpenTextDocumentParams()
            {
                TextDocument = new TextDocumentItem()
                {
                    Uri = documentUri,
                    LanguageId = "powerfx",
                    Version = 1,
                    Text = expression
                }
            });
            var rawResponse = await TestServer.OnDataReceivedAsync(payload).ConfigureAwait(false);
            var response = GetPublishExpressionTypeParams(rawResponse);

            Assert.Equal(documentUri, response.Uri);
            Assert.IsType(expectedType, response.Type);
        }

        [Theory]
        [InlineData("{\"A\": 1 }", "invalid+A")]
        [InlineData("{}", "B")]
        [InlineData("{}", "+")]
        public async Task TestPublishExpressionType_Null(string context, string expression)
        {
            var documentUri = $"powerfx://app?context={context}&getExpressionType=true";
            var payload = GetDidOpenPayload(new DidOpenTextDocumentParams()
            {
                TextDocument = new TextDocumentItem()
                {
                    Uri = documentUri,
                    LanguageId = "powerfx",
                    Version = 1,
                    Text = expression
                }
            });
            var rawResponse = await TestServer.OnDataReceivedAsync(payload).ConfigureAwait(false);
            var response = GetPublishExpressionTypeParams(rawResponse);
            Assert.Equal(documentUri, response.Uri);
            Assert.Null(response.Type);
        }

        [Theory]
        [InlineData(false, "{}", "{ A: 1 }", @"{""Type"":""Record"",""Fields"":{""A"":{""Type"":""Decimal""}}}")]
        [InlineData(false, "{}", "[1, 2]", @"{""Type"":""Table"",""Fields"":{""Value"":{""Type"":""Decimal""}}}")]
        [InlineData(true, "{}", "[{ A: 1 }, { B: true }]", @"{""Type"":""Table"",""Fields"":{""A"":{""Type"":""Decimal""},""B"":{""Type"":""Boolean""}}}")]
        [InlineData(false, "{}", "[{ A: 1 }, { B: true }]", @"{""Type"":""Table"",""Fields"":{""Value"":{""Type"":""Record"",""Fields"":{""A"":{""Type"":""Decimal""},""B"":{""Type"":""Boolean""}}}}}")]
        [InlineData(false, "{}", "{A: 1, B: { C: { D: \"Qwerty\" }, E: true } }", @"{""Type"":""Record"",""Fields"":{""A"":{""Type"":""Decimal""},""B"":{""Type"":""Record"",""Fields"":{""C"":{""Type"":""Record"",""Fields"":{""D"":{""Type"":""String""}}},""E"":{""Type"":""Boolean""}}}}}")]
        [InlineData(false, "{}", "{ type: 123 }", @"{""Type"":""Record"",""Fields"":{""type"":{""Type"":""Decimal""}}}")]
        public async Task TestPublishExpressionType_AggregateShapes(bool tableSyntaxDoesntWrapRecords, string context, string expression, string expectedTypeJson)
        {
            Init(new InitParams(features: new Features { TableSyntaxDoesntWrapRecords = tableSyntaxDoesntWrapRecords }));
            var documentUri = $"powerfx://app?context={context}&getExpressionType=true";
            var payload = GetDidOpenPayload(new DidOpenTextDocumentParams()
            {
                TextDocument = new TextDocumentItem()
                {
                    Uri = documentUri,
                    LanguageId = "powerfx",
                    Version = 1,
                    Text = expression
                }
            });
            var rawResponse = await TestServer.OnDataReceivedAsync(payload).ConfigureAwait(false);
            var response = GetPublishExpressionTypeParams(rawResponse);
            Assert.Equal(documentUri, response.Uri);
            Assert.Equal(expectedTypeJson, JsonRpcHelper.Serialize(response.Type));
        }

        private static string GetDidOpenPayload(DidOpenTextDocumentParams openTextDocumentParams)
        {
            return GetNotificationPayload(openTextDocumentParams, TextDocumentNames.DidOpen);
        }

        private static PublishTokensParams GetPublishTokensParams(string response)
        {
            return AssertAndGetNotificationParams<PublishTokensParams>(response, CustomProtocolNames.PublishTokens);
        }

        private static PublishExpressionTypeParams GetPublishExpressionTypeParams(string response)
        {
            return AssertAndGetNotificationParams<PublishExpressionTypeParams>(response, CustomProtocolNames.PublishExpressionType);
        }
    }
}
